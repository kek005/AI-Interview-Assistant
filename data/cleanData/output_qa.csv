Text Chunk,Generated Question,Generated Answer
"Azure Administrator Associate
Chapter 1: Prerequisites for Azure administrators

Modules in this learning path

Use Azure Resource Manager
You'll learn how to use resource groups to organize your Azure resources. Introduction to Azure Cloud Shell
Describe Microsoft Azure Cloud Shell, learn how it works, and explore basic steps for its usage. Introduction to Bash

Use Bash to manage IT infrastructure. Introduction to PowerShell
Learn about the basics of PowerShell, a cross-platform command-line shell and scripting language that's built for task automation and configuration management. Learn what PowerShell is, what it's used for, and how to use it. Configure resources with Azure Resource Manager templates
You'll learn how to use Azure Resource Manager templates to consistently deploy assets. Point 1: Use Azure Resource Manager
You'll learn how to use resource groups to organize your Azure resources. Learning objectives
After completing this module, you'll be able to:

Identify the features and usage cases for Azure Resource Manager. Describe each Azure Resource Manager component and its usage. Organize your Azure resources with resource groups. Apply Azure Resource Manager locks. Move Azure resources between groups, subscriptions, and regions. Remove resources and resource groups. Apply and track resource limits. Introduction
Scenario
Your company is beginning to create resources in Azure. There is no organizational plan for standardizing the effort. There have been several instances where critical resources were inadvertently deleted. It is difficult to determine who owns which resource. You need to use resource groups to organize the company's Azure resources. Skills measured
Managing resources is part of Exam AZ-104: Microsoft Azure Administrator. Manage Azure identities and governance (15–20%)

Manage subscriptions and governance

Configure resource locks. Manage resource groups. Deploy and manage Azure compute resources (20–25%)

Configure VMs

Move VMs from one resource group to another. Learning objectives
In this module, you'll learn how to:

Identify the features and usage cases for Azure Resource Manager. Describe each Azure Resource Manager component and its usage. Organize your Azure resources with resource groups. Apply Azure Resource Manager locks. Move Azure resources between groups, subscriptions, and regions. Remove resources and resource groups. Apply and track resource limits. Prerequisites
None

Next unit: Review Azure Resource Manager benefits

1- Review Azure Resource Manager benefits

The infrastructure for your application is typically made up of many components – maybe a virtual machine, storage account, and virtual network, or a web app, database, database server, and third-party services.",What are the key components and usage cases of Azure Resource Manager that an Azure Administrator should be familiar with?,"An Azure Administrator should be familiar with the components such as resource groups, Azure Resource Manager templates, and Azure Resource Manager locks. Usage cases include organizing resources with resource groups, deploying assets consistently with Azure Resource Manager templates, applying and tracking resource limits, and moving resources between groups, subscriptions, and regions."
"Azure Administrator Associate
Chapter 1: Prerequisites for Azure administrators

Modules in this learning path

Use Azure Resource Manager
You'll learn how to use resource groups to organize your Azure resources. Introduction to Azure Cloud Shell
Describe Microsoft Azure Cloud Shell, learn how it works, and explore basic steps for its usage. Introduction to Bash

Use Bash to manage IT infrastructure. Introduction to PowerShell
Learn about the basics of PowerShell, a cross-platform command-line shell and scripting language that's built for task automation and configuration management. Learn what PowerShell is, what it's used for, and how to use it. Configure resources with Azure Resource Manager templates
You'll learn how to use Azure Resource Manager templates to consistently deploy assets. Point 1: Use Azure Resource Manager
You'll learn how to use resource groups to organize your Azure resources. Learning objectives
After completing this module, you'll be able to:

Identify the features and usage cases for Azure Resource Manager. Describe each Azure Resource Manager component and its usage. Organize your Azure resources with resource groups. Apply Azure Resource Manager locks. Move Azure resources between groups, subscriptions, and regions. Remove resources and resource groups. Apply and track resource limits. Introduction
Scenario
Your company is beginning to create resources in Azure. There is no organizational plan for standardizing the effort. There have been several instances where critical resources were inadvertently deleted. It is difficult to determine who owns which resource. You need to use resource groups to organize the company's Azure resources. Skills measured
Managing resources is part of Exam AZ-104: Microsoft Azure Administrator. Manage Azure identities and governance (15–20%)

Manage subscriptions and governance

Configure resource locks. Manage resource groups. Deploy and manage Azure compute resources (20–25%)

Configure VMs

Move VMs from one resource group to another. Learning objectives
In this module, you'll learn how to:

Identify the features and usage cases for Azure Resource Manager. Describe each Azure Resource Manager component and its usage. Organize your Azure resources with resource groups. Apply Azure Resource Manager locks. Move Azure resources between groups, subscriptions, and regions. Remove resources and resource groups. Apply and track resource limits. Prerequisites
None

Next unit: Review Azure Resource Manager benefits

1- Review Azure Resource Manager benefits

The infrastructure for your application is typically made up of many components – maybe a virtual machine, storage account, and virtual network, or a web app, database, database server, and third-party services.",How can Azure Resource Manager locks help prevent critical resources from being inadvertently deleted in an organization?,"Azure Resource Manager locks can help prevent critical resources from being inadvertently deleted by applying restrictions at the resource level. This ensures that resources cannot be modified or deleted unless the lock is removed, thereby providing an additional layer of protection against accidental deletions."
"Azure Administrator Associate
Chapter 1: Prerequisites for Azure administrators

Modules in this learning path

Use Azure Resource Manager
You'll learn how to use resource groups to organize your Azure resources. Introduction to Azure Cloud Shell
Describe Microsoft Azure Cloud Shell, learn how it works, and explore basic steps for its usage. Introduction to Bash

Use Bash to manage IT infrastructure. Introduction to PowerShell
Learn about the basics of PowerShell, a cross-platform command-line shell and scripting language that's built for task automation and configuration management. Learn what PowerShell is, what it's used for, and how to use it. Configure resources with Azure Resource Manager templates
You'll learn how to use Azure Resource Manager templates to consistently deploy assets. Point 1: Use Azure Resource Manager
You'll learn how to use resource groups to organize your Azure resources. Learning objectives
After completing this module, you'll be able to:

Identify the features and usage cases for Azure Resource Manager. Describe each Azure Resource Manager component and its usage. Organize your Azure resources with resource groups. Apply Azure Resource Manager locks. Move Azure resources between groups, subscriptions, and regions. Remove resources and resource groups. Apply and track resource limits. Introduction
Scenario
Your company is beginning to create resources in Azure. There is no organizational plan for standardizing the effort. There have been several instances where critical resources were inadvertently deleted. It is difficult to determine who owns which resource. You need to use resource groups to organize the company's Azure resources. Skills measured
Managing resources is part of Exam AZ-104: Microsoft Azure Administrator. Manage Azure identities and governance (15–20%)

Manage subscriptions and governance

Configure resource locks. Manage resource groups. Deploy and manage Azure compute resources (20–25%)

Configure VMs

Move VMs from one resource group to another. Learning objectives
In this module, you'll learn how to:

Identify the features and usage cases for Azure Resource Manager. Describe each Azure Resource Manager component and its usage. Organize your Azure resources with resource groups. Apply Azure Resource Manager locks. Move Azure resources between groups, subscriptions, and regions. Remove resources and resource groups. Apply and track resource limits. Prerequisites
None

Next unit: Review Azure Resource Manager benefits

1- Review Azure Resource Manager benefits

The infrastructure for your application is typically made up of many components – maybe a virtual machine, storage account, and virtual network, or a web app, database, database server, and third-party services.","Why is it important for a company to use resource groups to organize its Azure resources, and how can this help solve ownership determination issues?","Using resource groups to organize Azure resources is important because it provides a structured way to manage and deploy related resources together. This approach can help solve ownership determination issues by assigning clear ownership to each resource group, making it easier to track and manage resources within the organization."
"These components are not separate entities, instead they are related and interdependent parts of a single entity. You want to deploy, manage, and monitor them as a group. Azure Resource Manager enables you to work with the resources in your solution as a group. You can deploy, update, or delete all the resources for your solution in a single, coordinated operation. You use a template for deployment and that template can work for different environments such as testing, staging, and production. Azure Resource Manager provides security, auditing, and tagging features to help you manage your resources after deployment. Consistent management layer
Azure Resource Manager provides a consistent management layer to perform tasks through Azure PowerShell, Azure CLI, Azure portal, REST API, and client SDKs. Choose the tools and APIs that work best for you. The following image shows how all the tools interact with the same Azure Resource Manager API. The API passes requests to the Azure Resource Manager service, which authenticates and authorizes the requests. Azure Resource Manager then routes the requests to the appropriate resource providers. Diagram of the Resource Manager request model. Benefits
Azure Resource Manager provides several benefits:

You can deploy, manage, and monitor all the resources for your solution as a group, rather than handling these resources individually. You can repeatedly deploy your solution throughout the development lifecycle and have confidence your resources are deployed in a consistent state. You can manage your infrastructure through declarative templates rather than scripts. You can define the dependencies between resources so they're deployed in the correct order. You can apply access control to all services in your resource group because Role-Based Access Control (RBAC) is natively integrated into the management platform. You can apply tags to resources to logically organize all the resources in your subscription. You can clarify your organization's billing by viewing costs for a group of resources sharing the same tag. Guidance
The following suggestions help you take full advantage of Azure Resource Manager when working with your solutions. Define and deploy your infrastructure through the declarative syntax in Azure Resource Manager templates, rather than through imperative commands. Define all deployment and configuration steps in the template. You should have no manual steps for setting up your solution. Run imperative commands to manage your resources, such as to start or stop an app or machine. Arrange resources with the same lifecycle in a resource group. Use tags for all other organizing of resources. Next unit: Review Azure resource terminology

2- Review Azure resource terminology

If you're new to Azure Resource Manager, there are some terms you might not be familiar with.",What is the primary function of Azure Resource Manager in managing resources?,"Azure Resource Manager facilitates the deployment, management, and monitoring of resources as a group, allowing for coordinated operations such as deploying, updating, or deleting resources simultaneously. It provides a consistent management layer and supports security, auditing, and tagging to help manage resources effectively."
"These components are not separate entities, instead they are related and interdependent parts of a single entity. You want to deploy, manage, and monitor them as a group. Azure Resource Manager enables you to work with the resources in your solution as a group. You can deploy, update, or delete all the resources for your solution in a single, coordinated operation. You use a template for deployment and that template can work for different environments such as testing, staging, and production. Azure Resource Manager provides security, auditing, and tagging features to help you manage your resources after deployment. Consistent management layer
Azure Resource Manager provides a consistent management layer to perform tasks through Azure PowerShell, Azure CLI, Azure portal, REST API, and client SDKs. Choose the tools and APIs that work best for you. The following image shows how all the tools interact with the same Azure Resource Manager API. The API passes requests to the Azure Resource Manager service, which authenticates and authorizes the requests. Azure Resource Manager then routes the requests to the appropriate resource providers. Diagram of the Resource Manager request model. Benefits
Azure Resource Manager provides several benefits:

You can deploy, manage, and monitor all the resources for your solution as a group, rather than handling these resources individually. You can repeatedly deploy your solution throughout the development lifecycle and have confidence your resources are deployed in a consistent state. You can manage your infrastructure through declarative templates rather than scripts. You can define the dependencies between resources so they're deployed in the correct order. You can apply access control to all services in your resource group because Role-Based Access Control (RBAC) is natively integrated into the management platform. You can apply tags to resources to logically organize all the resources in your subscription. You can clarify your organization's billing by viewing costs for a group of resources sharing the same tag. Guidance
The following suggestions help you take full advantage of Azure Resource Manager when working with your solutions. Define and deploy your infrastructure through the declarative syntax in Azure Resource Manager templates, rather than through imperative commands. Define all deployment and configuration steps in the template. You should have no manual steps for setting up your solution. Run imperative commands to manage your resources, such as to start or stop an app or machine. Arrange resources with the same lifecycle in a resource group. Use tags for all other organizing of resources. Next unit: Review Azure resource terminology

2- Review Azure resource terminology

If you're new to Azure Resource Manager, there are some terms you might not be familiar with.",How does Azure Resource Manager enhance the deployment process across different environments?,"Azure Resource Manager uses templates for deployment, which can be utilized across various environments like testing, staging, and production. This ensures that resources are deployed in a consistent state, and dependencies are managed properly to deploy resources in the correct order."
"These components are not separate entities, instead they are related and interdependent parts of a single entity. You want to deploy, manage, and monitor them as a group. Azure Resource Manager enables you to work with the resources in your solution as a group. You can deploy, update, or delete all the resources for your solution in a single, coordinated operation. You use a template for deployment and that template can work for different environments such as testing, staging, and production. Azure Resource Manager provides security, auditing, and tagging features to help you manage your resources after deployment. Consistent management layer
Azure Resource Manager provides a consistent management layer to perform tasks through Azure PowerShell, Azure CLI, Azure portal, REST API, and client SDKs. Choose the tools and APIs that work best for you. The following image shows how all the tools interact with the same Azure Resource Manager API. The API passes requests to the Azure Resource Manager service, which authenticates and authorizes the requests. Azure Resource Manager then routes the requests to the appropriate resource providers. Diagram of the Resource Manager request model. Benefits
Azure Resource Manager provides several benefits:

You can deploy, manage, and monitor all the resources for your solution as a group, rather than handling these resources individually. You can repeatedly deploy your solution throughout the development lifecycle and have confidence your resources are deployed in a consistent state. You can manage your infrastructure through declarative templates rather than scripts. You can define the dependencies between resources so they're deployed in the correct order. You can apply access control to all services in your resource group because Role-Based Access Control (RBAC) is natively integrated into the management platform. You can apply tags to resources to logically organize all the resources in your subscription. You can clarify your organization's billing by viewing costs for a group of resources sharing the same tag. Guidance
The following suggestions help you take full advantage of Azure Resource Manager when working with your solutions. Define and deploy your infrastructure through the declarative syntax in Azure Resource Manager templates, rather than through imperative commands. Define all deployment and configuration steps in the template. You should have no manual steps for setting up your solution. Run imperative commands to manage your resources, such as to start or stop an app or machine. Arrange resources with the same lifecycle in a resource group. Use tags for all other organizing of resources. Next unit: Review Azure resource terminology

2- Review Azure resource terminology

If you're new to Azure Resource Manager, there are some terms you might not be familiar with.",What are the benefits of using declarative templates in Azure Resource Manager?,"Declarative templates in Azure Resource Manager allow for defining and deploying infrastructure without manual steps, ensuring consistency. They allow for defining resource dependencies, applying Role-Based Access Control across resource groups, and organizing resources with tags to streamline management and billing."
"resource - A manageable item that is available through Azure. Some common resources are a virtual machine, storage account, web app, database, and virtual network, but there are many more. resource group - A container that holds related resources for an Azure solution. The resource group can include all the resources for the solution, or only those resources that you want to manage as a group. You decide how you want to allocate resources to resource groups based on what makes the most sense for your organization. resource provider - A service that supplies the resources you can deploy and manage through Resource Manager. Each resource provider offers operations for working with the resources that are deployed. Some common resource providers are Microsoft.Compute, which supplies the virtual machine resource, Microsoft.Storage, which supplies the storage account resource, and Microsoft.Web, which supplies resources related to web apps. template - A JavaScript Object Notation (JSON) file that defines one or more resources to deploy to a resource group. It also defines the dependencies between the deployed resources. The template can be used to deploy the resources consistently and repeatedly. declarative syntax - Syntax that lets you state ""Here is what I intend to create"" without having to write the sequence of programming commands to create it. The Resource Manager template is an example of declarative syntax. In the file, you define the properties for the infrastructure to deploy to Azure. Resource providers
Each resource provider offers a set of resources and operations for working with an Azure service. For example, if you want to store keys and secrets, you work with the Microsoft.KeyVault resource provider. This resource provider offers a resource type called vaults for creating the key vault. The name of a resource type is in the format: {resource-provider}/{resource-type}. For example, the key vault type is Microsoft.KeyVault/vaults. Note

Before deploying your resources, you should gain an understanding of the available resource providers. Knowing the names of resource providers and resources helps you define resources you want to deploy to Azure. Also, you need to know the valid locations and API versions for each resource type. Next unit: Create resource groups

3- Create resource groups

Resources can be deployed to any new or existing resource group. Deployment of resources to a resource group becomes a job where you can track the template execution. If deployment fails, the output of the job can describe why the deployment failed. Whether the deployment is a single resource to a group or a template to a group, you can use the information to fix any errors and redeploy.","What is a resource group in Azure, and how can it be used in managing resources?","A resource group in Azure is a container that holds related resources for an Azure solution. It can include all the resources for the solution, or only those resources that you want to manage as a group. Resource groups allow you to organize and manage resources based on what makes the most sense for your organization."
"resource - A manageable item that is available through Azure. Some common resources are a virtual machine, storage account, web app, database, and virtual network, but there are many more. resource group - A container that holds related resources for an Azure solution. The resource group can include all the resources for the solution, or only those resources that you want to manage as a group. You decide how you want to allocate resources to resource groups based on what makes the most sense for your organization. resource provider - A service that supplies the resources you can deploy and manage through Resource Manager. Each resource provider offers operations for working with the resources that are deployed. Some common resource providers are Microsoft.Compute, which supplies the virtual machine resource, Microsoft.Storage, which supplies the storage account resource, and Microsoft.Web, which supplies resources related to web apps. template - A JavaScript Object Notation (JSON) file that defines one or more resources to deploy to a resource group. It also defines the dependencies between the deployed resources. The template can be used to deploy the resources consistently and repeatedly. declarative syntax - Syntax that lets you state ""Here is what I intend to create"" without having to write the sequence of programming commands to create it. The Resource Manager template is an example of declarative syntax. In the file, you define the properties for the infrastructure to deploy to Azure. Resource providers
Each resource provider offers a set of resources and operations for working with an Azure service. For example, if you want to store keys and secrets, you work with the Microsoft.KeyVault resource provider. This resource provider offers a resource type called vaults for creating the key vault. The name of a resource type is in the format: {resource-provider}/{resource-type}. For example, the key vault type is Microsoft.KeyVault/vaults. Note

Before deploying your resources, you should gain an understanding of the available resource providers. Knowing the names of resource providers and resources helps you define resources you want to deploy to Azure. Also, you need to know the valid locations and API versions for each resource type. Next unit: Create resource groups

3- Create resource groups

Resources can be deployed to any new or existing resource group. Deployment of resources to a resource group becomes a job where you can track the template execution. If deployment fails, the output of the job can describe why the deployment failed. Whether the deployment is a single resource to a group or a template to a group, you can use the information to fix any errors and redeploy.",How does a Resource Manager template utilize declarative syntax in Azure?,"A Resource Manager template uses declarative syntax to define one or more resources to deploy to a resource group. Instead of writing the sequence of programming commands, you state ""Here is what I intend to create"" and define the properties for the infrastructure. This allows for consistent and repeated deployment of resources."
"resource - A manageable item that is available through Azure. Some common resources are a virtual machine, storage account, web app, database, and virtual network, but there are many more. resource group - A container that holds related resources for an Azure solution. The resource group can include all the resources for the solution, or only those resources that you want to manage as a group. You decide how you want to allocate resources to resource groups based on what makes the most sense for your organization. resource provider - A service that supplies the resources you can deploy and manage through Resource Manager. Each resource provider offers operations for working with the resources that are deployed. Some common resource providers are Microsoft.Compute, which supplies the virtual machine resource, Microsoft.Storage, which supplies the storage account resource, and Microsoft.Web, which supplies resources related to web apps. template - A JavaScript Object Notation (JSON) file that defines one or more resources to deploy to a resource group. It also defines the dependencies between the deployed resources. The template can be used to deploy the resources consistently and repeatedly. declarative syntax - Syntax that lets you state ""Here is what I intend to create"" without having to write the sequence of programming commands to create it. The Resource Manager template is an example of declarative syntax. In the file, you define the properties for the infrastructure to deploy to Azure. Resource providers
Each resource provider offers a set of resources and operations for working with an Azure service. For example, if you want to store keys and secrets, you work with the Microsoft.KeyVault resource provider. This resource provider offers a resource type called vaults for creating the key vault. The name of a resource type is in the format: {resource-provider}/{resource-type}. For example, the key vault type is Microsoft.KeyVault/vaults. Note

Before deploying your resources, you should gain an understanding of the available resource providers. Knowing the names of resource providers and resources helps you define resources you want to deploy to Azure. Also, you need to know the valid locations and API versions for each resource type. Next unit: Create resource groups

3- Create resource groups

Resources can be deployed to any new or existing resource group. Deployment of resources to a resource group becomes a job where you can track the template execution. If deployment fails, the output of the job can describe why the deployment failed. Whether the deployment is a single resource to a group or a template to a group, you can use the information to fix any errors and redeploy.",Why is it important to understand resource providers before deploying resources in Azure?,"Understanding resource providers is important before deploying resources in Azure because each provider offers a set of resources and operations for working with an Azure service. Knowing the names of resource providers, resources, valid locations, and API versions helps you correctly define and deploy the resources you want to manage in Azure."
"Deployments are incremental; if a resource group contains two web apps and you decide to deploy a third, the existing web apps will not be removed. Considerations
Resource Groups are at their simplest a logical collection of resources. There are a few rules for resource groups. Resources can only exist in one resource group. Resource Groups cannot be renamed. Resource Groups can have resources of many different types (services). Resource Groups can have resources from many different regions. Creating resource groups
There are some important factors to consider when defining your resource group:

All the resources in your group should share the same lifecycle. You deploy, update, and delete them together. If one resource, such as a database server, needs to exist on a different deployment cycle it should be in another resource group. Each resource can only exist in one resource group. You can add or remove a resource to a resource group at any time. You can move a resource from one resource group to another group. Limitations do apply to moving resources. A resource group can contain resources that reside in different regions. A resource group can be used to scope access control for administrative actions. A resource can interact with resources in other resource groups. This interaction is common when the two resources are related but don't share the same lifecycle (for example, web apps connecting to a database). When creating a resource group, you need to provide a location for that resource group. You may be wondering, ""Why does a resource group need a location? And, if the resources can have different locations than the resource group, why does the resource group location matter at all?"" The resource group stores metadata about the resources. Therefore, when you specify a location for the resource group, you're specifying where that metadata is stored. For compliance reasons, you may need to ensure that your data is stored in a particular region. Note

By scoping permissions to a resource group, you can add/remove and modify resources easily without having to recreate assignments and scopes. Next unit: Create Azure Resource Manager locks

4- Create Azure Resource Manager locks

A common concern with resources provisioned in Azure is the ease with which they can be deleted. An over-zealous or careless administrator can accidentally erase months of work with a few steps. Resource Manager locks allow organizations to put a structure in place that prevents the accidental deletion of resources in Azure. You can associate the lock with a subscription, resource group, or resource. Locks are inherited by child resources. Screenshot of the Management locks page.",What are some key considerations when defining a resource group in Azure?,"When defining a resource group in Azure, it is important to ensure that all resources within the group share the same lifecycle, meaning they are deployed, updated, and deleted together. Resources that need different deployment cycles should be in separate resource groups. Additionally, while a resource can only exist in one resource group at a time, it is possible to move resources between groups, although there are limitations to this process. Resource groups can also contain resources from different regions and can be used to scope access control for administrative actions."
"Deployments are incremental; if a resource group contains two web apps and you decide to deploy a third, the existing web apps will not be removed. Considerations
Resource Groups are at their simplest a logical collection of resources. There are a few rules for resource groups. Resources can only exist in one resource group. Resource Groups cannot be renamed. Resource Groups can have resources of many different types (services). Resource Groups can have resources from many different regions. Creating resource groups
There are some important factors to consider when defining your resource group:

All the resources in your group should share the same lifecycle. You deploy, update, and delete them together. If one resource, such as a database server, needs to exist on a different deployment cycle it should be in another resource group. Each resource can only exist in one resource group. You can add or remove a resource to a resource group at any time. You can move a resource from one resource group to another group. Limitations do apply to moving resources. A resource group can contain resources that reside in different regions. A resource group can be used to scope access control for administrative actions. A resource can interact with resources in other resource groups. This interaction is common when the two resources are related but don't share the same lifecycle (for example, web apps connecting to a database). When creating a resource group, you need to provide a location for that resource group. You may be wondering, ""Why does a resource group need a location? And, if the resources can have different locations than the resource group, why does the resource group location matter at all?"" The resource group stores metadata about the resources. Therefore, when you specify a location for the resource group, you're specifying where that metadata is stored. For compliance reasons, you may need to ensure that your data is stored in a particular region. Note

By scoping permissions to a resource group, you can add/remove and modify resources easily without having to recreate assignments and scopes. Next unit: Create Azure Resource Manager locks

4- Create Azure Resource Manager locks

A common concern with resources provisioned in Azure is the ease with which they can be deleted. An over-zealous or careless administrator can accidentally erase months of work with a few steps. Resource Manager locks allow organizations to put a structure in place that prevents the accidental deletion of resources in Azure. You can associate the lock with a subscription, resource group, or resource. Locks are inherited by child resources. Screenshot of the Management locks page.","Why does a resource group in Azure require a specific location, and how does this impact compliance?","A resource group requires a specific location because it stores metadata about the resources within it, and the location determines where this metadata is stored. This is important for compliance reasons, as organizations may need to ensure that their data, including metadata, is stored in a particular region to meet regulatory or policy requirements."
"Deployments are incremental; if a resource group contains two web apps and you decide to deploy a third, the existing web apps will not be removed. Considerations
Resource Groups are at their simplest a logical collection of resources. There are a few rules for resource groups. Resources can only exist in one resource group. Resource Groups cannot be renamed. Resource Groups can have resources of many different types (services). Resource Groups can have resources from many different regions. Creating resource groups
There are some important factors to consider when defining your resource group:

All the resources in your group should share the same lifecycle. You deploy, update, and delete them together. If one resource, such as a database server, needs to exist on a different deployment cycle it should be in another resource group. Each resource can only exist in one resource group. You can add or remove a resource to a resource group at any time. You can move a resource from one resource group to another group. Limitations do apply to moving resources. A resource group can contain resources that reside in different regions. A resource group can be used to scope access control for administrative actions. A resource can interact with resources in other resource groups. This interaction is common when the two resources are related but don't share the same lifecycle (for example, web apps connecting to a database). When creating a resource group, you need to provide a location for that resource group. You may be wondering, ""Why does a resource group need a location? And, if the resources can have different locations than the resource group, why does the resource group location matter at all?"" The resource group stores metadata about the resources. Therefore, when you specify a location for the resource group, you're specifying where that metadata is stored. For compliance reasons, you may need to ensure that your data is stored in a particular region. Note

By scoping permissions to a resource group, you can add/remove and modify resources easily without having to recreate assignments and scopes. Next unit: Create Azure Resource Manager locks

4- Create Azure Resource Manager locks

A common concern with resources provisioned in Azure is the ease with which they can be deleted. An over-zealous or careless administrator can accidentally erase months of work with a few steps. Resource Manager locks allow organizations to put a structure in place that prevents the accidental deletion of resources in Azure. You can associate the lock with a subscription, resource group, or resource. Locks are inherited by child resources. Screenshot of the Management locks page.",How do Azure Resource Manager locks help prevent accidental deletion of resources?,"Azure Resource Manager locks help prevent accidental deletion of resources by allowing organizations to place restrictions on resources, resource groups, or subscriptions. These locks can prevent modifications and deletions, thereby protecting resources from being accidentally erased by an administrator. Locks are inherited by child resources, providing a comprehensive safeguard against unintended changes or deletions."
"In the Settings options, Locks are highlighted and in the Add Lock page, the Lock type, Ready-only, and Delete option are displayed and highlighted. Lock types
There are two types of resource locks. Read-Only locks, which prevent any changes to the resource. Delete locks, which prevent deletion. Note

Only the Owner and User Access Administrator roles can create or delete management locks. Next unit: Reorganize Azure resources

5- Reorganize Azure resources

Sometimes you may need to move resources to either a new subscription or a new resource group in the same subscription. Diagram showing two subscriptions. When moving resources, both the source group and the target group are locked during the operation. Write and delete operations are blocked on the resource groups until the move completes. This lock means you can't add, update, or delete resources in the resource groups. Locks don't mean the resources aren't available. For example, if you move a virtual machine to a new resource group, an application can still access the virtual machine. Limitations
Before beginning this process be sure to read the Move operation support for resources page. This page details what resources can be moved between resources group, subscriptions, and regions. Implementation
To move resources, select the resource group containing those resources, and then select the Move button. Select the resources to move and the destination resource group. Acknowledge that you need to update scripts. Screenshot of the Move a Resource page. Note

Just because a service can be moved doesn’t mean there aren’t restrictions. For example, you can move a virtual network, but you must also move its dependent resources, like gateways. Next unit: Remove resources and resource groups

6- Remove resources and resource groups

Use caution when deleting a resource group. Deleting a resource group deletes all the resources contained within it. That resource group might contain resources that resources in other resource groups depend on. Screenshot showing the Delete resource group button (highlighted) in the portal. Using PowerShell to delete resource groups
To remove a resource group use, Remove-AzResourceGroup. In this example, we are removing the ContosoRG01 resource group from the subscription. The cmdlet prompts you for confirmation and returns no output. Copy
Remove-AzResourceGroup -Name ""ContosoRG01""

Removing resources
You can also delete individual resources within a resource group. For example, here we are deleting a virtual network. Instead, of deleting you can move the resource to another resource group.","What are the two types of resource locks available, and what are their functions?","The two types of resource locks are Read-Only locks and Delete locks. Read-Only locks prevent any changes to the resource, while Delete locks prevent the deletion of a resource."
"In the Settings options, Locks are highlighted and in the Add Lock page, the Lock type, Ready-only, and Delete option are displayed and highlighted. Lock types
There are two types of resource locks. Read-Only locks, which prevent any changes to the resource. Delete locks, which prevent deletion. Note

Only the Owner and User Access Administrator roles can create or delete management locks. Next unit: Reorganize Azure resources

5- Reorganize Azure resources

Sometimes you may need to move resources to either a new subscription or a new resource group in the same subscription. Diagram showing two subscriptions. When moving resources, both the source group and the target group are locked during the operation. Write and delete operations are blocked on the resource groups until the move completes. This lock means you can't add, update, or delete resources in the resource groups. Locks don't mean the resources aren't available. For example, if you move a virtual machine to a new resource group, an application can still access the virtual machine. Limitations
Before beginning this process be sure to read the Move operation support for resources page. This page details what resources can be moved between resources group, subscriptions, and regions. Implementation
To move resources, select the resource group containing those resources, and then select the Move button. Select the resources to move and the destination resource group. Acknowledge that you need to update scripts. Screenshot of the Move a Resource page. Note

Just because a service can be moved doesn’t mean there aren’t restrictions. For example, you can move a virtual network, but you must also move its dependent resources, like gateways. Next unit: Remove resources and resource groups

6- Remove resources and resource groups

Use caution when deleting a resource group. Deleting a resource group deletes all the resources contained within it. That resource group might contain resources that resources in other resource groups depend on. Screenshot showing the Delete resource group button (highlighted) in the portal. Using PowerShell to delete resource groups
To remove a resource group use, Remove-AzResourceGroup. In this example, we are removing the ContosoRG01 resource group from the subscription. The cmdlet prompts you for confirmation and returns no output. Copy
Remove-AzResourceGroup -Name ""ContosoRG01""

Removing resources
You can also delete individual resources within a resource group. For example, here we are deleting a virtual network. Instead, of deleting you can move the resource to another resource group.",Who is authorized to create or delete management locks on resources?,Only individuals with the Owner and User Access Administrator roles are authorized to create or delete management locks on resources.
"In the Settings options, Locks are highlighted and in the Add Lock page, the Lock type, Ready-only, and Delete option are displayed and highlighted. Lock types
There are two types of resource locks. Read-Only locks, which prevent any changes to the resource. Delete locks, which prevent deletion. Note

Only the Owner and User Access Administrator roles can create or delete management locks. Next unit: Reorganize Azure resources

5- Reorganize Azure resources

Sometimes you may need to move resources to either a new subscription or a new resource group in the same subscription. Diagram showing two subscriptions. When moving resources, both the source group and the target group are locked during the operation. Write and delete operations are blocked on the resource groups until the move completes. This lock means you can't add, update, or delete resources in the resource groups. Locks don't mean the resources aren't available. For example, if you move a virtual machine to a new resource group, an application can still access the virtual machine. Limitations
Before beginning this process be sure to read the Move operation support for resources page. This page details what resources can be moved between resources group, subscriptions, and regions. Implementation
To move resources, select the resource group containing those resources, and then select the Move button. Select the resources to move and the destination resource group. Acknowledge that you need to update scripts. Screenshot of the Move a Resource page. Note

Just because a service can be moved doesn’t mean there aren’t restrictions. For example, you can move a virtual network, but you must also move its dependent resources, like gateways. Next unit: Remove resources and resource groups

6- Remove resources and resource groups

Use caution when deleting a resource group. Deleting a resource group deletes all the resources contained within it. That resource group might contain resources that resources in other resource groups depend on. Screenshot showing the Delete resource group button (highlighted) in the portal. Using PowerShell to delete resource groups
To remove a resource group use, Remove-AzResourceGroup. In this example, we are removing the ContosoRG01 resource group from the subscription. The cmdlet prompts you for confirmation and returns no output. Copy
Remove-AzResourceGroup -Name ""ContosoRG01""

Removing resources
You can also delete individual resources within a resource group. For example, here we are deleting a virtual network. Instead, of deleting you can move the resource to another resource group.","What precautions should be taken before deleting a resource group, and how can it be done using PowerShell?","Before deleting a resource group, it is important to be cautious as deleting it removes all resources within it, which might affect dependencies with other resource groups. It can be done using PowerShell with the command Remove-AzResourceGroup, followed by the resource group's name."
"Screenshot from the portal of the route table page, with the Delete button highlighted to show you can delete an individual resource within a resource group. Next unit: Determine resource limits

7- Determine resource limits

Azure lets you view resource usage against limits. This is helpful to track current usage, and plan for future use. Screenshot of the Subscription usage and quotas page. It shows quotas for Network Watchers, Public IP Addresses, Route Tables, and Virtual Networks by their location with the usage numbers by percent used and number of resources. The limits shown are the limits for your subscription. When you need to increase a default limit, there is a Request Increase link. All resources have a maximum limit listed in Azure limits. If you are at the maximum limit, the limit can't be increased. Next unit: Knowledge check

Knowledge check

Choose the best response for each question. Then select Check your answers. 1. A new project has several resources that need to be administered together. Which of the following strategies would provide a good solution? Azure templates

Azure resource groups

Azure subscriptions

2. Which of the following situations would be good example of when to use a resource lock? A ExpressRoute circuit with connectivity back to the on-premises network. A non-production virtual machine used to test occasional application builds. A storage account used to temporarily store images processed in a development environment. 3. Which of the following is true about resource groups? Resources can be in only one resource group. Role-based access control can't be applied to a resource group

Resource groups can be nested. Summary and resources

Azure Resource Manager is the deployment and management service for Azure. It provides a management layer that enables you to create, update, and delete resources in your Azure account. You use management features, like access control, locks, and tags, to secure and organize your resources after deployment. You should now be able to:

Identify the features and usage cases for Azure Resource Manager. Describe each Azure Resource Manager component and its usage. Organize your Azure resources with resource groups. Apply Azure Resource Manager locks. Move Azure resources between groups, subscriptions, and regions. Remove resources and resource groups. Apply and track resource limits. Learn more
You can learn more by reviewing the following. Azure Resource Manager documentation
Learn - Control and organize Azure resources with Azure Resource Manager



Point 2: Introduction to Azure Cloud Shell

Describe Microsoft Azure Cloud Shell, learn how it works, and explore basic steps for its usage.",What is the purpose of tracking resource usage against limits in Azure?,"Tracking resource usage against limits in Azure helps users monitor their current usage and plan for future needs. It allows users to view quotas for various resources and request an increase if necessary, provided they are not already at the maximum limit."
"Screenshot from the portal of the route table page, with the Delete button highlighted to show you can delete an individual resource within a resource group. Next unit: Determine resource limits

7- Determine resource limits

Azure lets you view resource usage against limits. This is helpful to track current usage, and plan for future use. Screenshot of the Subscription usage and quotas page. It shows quotas for Network Watchers, Public IP Addresses, Route Tables, and Virtual Networks by their location with the usage numbers by percent used and number of resources. The limits shown are the limits for your subscription. When you need to increase a default limit, there is a Request Increase link. All resources have a maximum limit listed in Azure limits. If you are at the maximum limit, the limit can't be increased. Next unit: Knowledge check

Knowledge check

Choose the best response for each question. Then select Check your answers. 1. A new project has several resources that need to be administered together. Which of the following strategies would provide a good solution? Azure templates

Azure resource groups

Azure subscriptions

2. Which of the following situations would be good example of when to use a resource lock? A ExpressRoute circuit with connectivity back to the on-premises network. A non-production virtual machine used to test occasional application builds. A storage account used to temporarily store images processed in a development environment. 3. Which of the following is true about resource groups? Resources can be in only one resource group. Role-based access control can't be applied to a resource group

Resource groups can be nested. Summary and resources

Azure Resource Manager is the deployment and management service for Azure. It provides a management layer that enables you to create, update, and delete resources in your Azure account. You use management features, like access control, locks, and tags, to secure and organize your resources after deployment. You should now be able to:

Identify the features and usage cases for Azure Resource Manager. Describe each Azure Resource Manager component and its usage. Organize your Azure resources with resource groups. Apply Azure Resource Manager locks. Move Azure resources between groups, subscriptions, and regions. Remove resources and resource groups. Apply and track resource limits. Learn more
You can learn more by reviewing the following. Azure Resource Manager documentation
Learn - Control and organize Azure resources with Azure Resource Manager



Point 2: Introduction to Azure Cloud Shell

Describe Microsoft Azure Cloud Shell, learn how it works, and explore basic steps for its usage.","What are some features of the Azure Resource Manager, and how do they benefit users?","Azure Resource Manager is a deployment and management service that allows users to create, update, and delete resources in their Azure account. It provides features like access control, locks, and tags, which help secure and organize resources. It also supports organizing resources into groups and moving them between groups, subscriptions, and regions."
"Screenshot from the portal of the route table page, with the Delete button highlighted to show you can delete an individual resource within a resource group. Next unit: Determine resource limits

7- Determine resource limits

Azure lets you view resource usage against limits. This is helpful to track current usage, and plan for future use. Screenshot of the Subscription usage and quotas page. It shows quotas for Network Watchers, Public IP Addresses, Route Tables, and Virtual Networks by their location with the usage numbers by percent used and number of resources. The limits shown are the limits for your subscription. When you need to increase a default limit, there is a Request Increase link. All resources have a maximum limit listed in Azure limits. If you are at the maximum limit, the limit can't be increased. Next unit: Knowledge check

Knowledge check

Choose the best response for each question. Then select Check your answers. 1. A new project has several resources that need to be administered together. Which of the following strategies would provide a good solution? Azure templates

Azure resource groups

Azure subscriptions

2. Which of the following situations would be good example of when to use a resource lock? A ExpressRoute circuit with connectivity back to the on-premises network. A non-production virtual machine used to test occasional application builds. A storage account used to temporarily store images processed in a development environment. 3. Which of the following is true about resource groups? Resources can be in only one resource group. Role-based access control can't be applied to a resource group

Resource groups can be nested. Summary and resources

Azure Resource Manager is the deployment and management service for Azure. It provides a management layer that enables you to create, update, and delete resources in your Azure account. You use management features, like access control, locks, and tags, to secure and organize your resources after deployment. You should now be able to:

Identify the features and usage cases for Azure Resource Manager. Describe each Azure Resource Manager component and its usage. Organize your Azure resources with resource groups. Apply Azure Resource Manager locks. Move Azure resources between groups, subscriptions, and regions. Remove resources and resource groups. Apply and track resource limits. Learn more
You can learn more by reviewing the following. Azure Resource Manager documentation
Learn - Control and organize Azure resources with Azure Resource Manager



Point 2: Introduction to Azure Cloud Shell

Describe Microsoft Azure Cloud Shell, learn how it works, and explore basic steps for its usage.",How does Azure Cloud Shell enhance the user experience in managing Azure resources?,"Azure Cloud Shell provides a browser-based command-line experience that allows users to manage and automate Azure resources without the need for local installation. It supports multiple languages and tools, making it convenient for executing scripts and managing resources directly from the Azure portal."
"Learning objectives

By the end of this module, you're able to:

Describe Azure Cloud Shell and the functionality it provides. Determine whether Azure Cloud Shell meets the needs of your organization. Recognize how to use Azure Cloud Shell and persist files for multiple sessions. 1- Introduction

Azure Cloud Shell is a browser-accessible command-line experience for managing Azure resources. It provides the flexibility of choosing the shell experience that best suits the way you work, either Bash or PowerShell. Traditionally, to interact with Azure resources via command-line, you need to install the necessary components into your local computer (PC, Mac, Linux). With Cloud Shell, you have an authenticated, interactive shell that isn't part of a local machine. You're an IT admin for Contoso Corporation, responsible for the cloud infrastructure on which the company hosts its applications. These applications use different cloud resources, such as Azure VMs, Azure blob storage, Azure networking, and others. On many occasions, you're asked to perform operations on these cloud resources at moments when you’re not using your work laptop. In some cases, you have a friend’s laptop, a smartphone, or another personal PC. This module explains what Azure Cloud Shell does, how it works, and when you should choose to use Cloud Shell as a solution to meet your organization's needs. Learning objectives
In this module, you'll:

Describe Azure Cloud Shell and the functionality it provides. Determine whether Cloud Shell meets the needs of your organization. Recognize how to use Cloud Shell and persist files for multiple sessions. Next unit: What is Azure Cloud Shell? 2- What is Azure Cloud Shell? Azure Cloud Shell is a command-line environment you can access through your web browser. You can use this environment to manage Azure resources, including VMs, storage, and networking. Just like you do when using the Azure CLI or Azure PowerShell. Because Microsoft manages Cloud Shell, you always have access to the most recent versions of the Azure CLI and PowerShell modules right from any browser. You don't have to worry about keeping modules up to date. With Cloud Shell, you just open your browser and sign in. Just like that, you have access to a command-line environment fully connected with your account's permissions and the resources to which you have access. All that works in an infrastructure that's compliant with double encryption at rest by default. You don't need to take any further action! Azure Cloud Shell also provides cloud storage to persist files such as SSH keys, scripts, and more.",What is Azure Cloud Shell and what functionality does it provide?,"Azure Cloud Shell is a browser-accessible command-line experience for managing Azure resources. It allows users to choose between Bash or PowerShell for their shell experience and provides an authenticated, interactive shell that is not part of a local machine. This enables operations on Azure resources like VMs, storage, and networking without the need to install components locally. Cloud Shell also includes cloud storage to persist files such as SSH keys and scripts."
"Learning objectives

By the end of this module, you're able to:

Describe Azure Cloud Shell and the functionality it provides. Determine whether Azure Cloud Shell meets the needs of your organization. Recognize how to use Azure Cloud Shell and persist files for multiple sessions. 1- Introduction

Azure Cloud Shell is a browser-accessible command-line experience for managing Azure resources. It provides the flexibility of choosing the shell experience that best suits the way you work, either Bash or PowerShell. Traditionally, to interact with Azure resources via command-line, you need to install the necessary components into your local computer (PC, Mac, Linux). With Cloud Shell, you have an authenticated, interactive shell that isn't part of a local machine. You're an IT admin for Contoso Corporation, responsible for the cloud infrastructure on which the company hosts its applications. These applications use different cloud resources, such as Azure VMs, Azure blob storage, Azure networking, and others. On many occasions, you're asked to perform operations on these cloud resources at moments when you’re not using your work laptop. In some cases, you have a friend’s laptop, a smartphone, or another personal PC. This module explains what Azure Cloud Shell does, how it works, and when you should choose to use Cloud Shell as a solution to meet your organization's needs. Learning objectives
In this module, you'll:

Describe Azure Cloud Shell and the functionality it provides. Determine whether Cloud Shell meets the needs of your organization. Recognize how to use Cloud Shell and persist files for multiple sessions. Next unit: What is Azure Cloud Shell? 2- What is Azure Cloud Shell? Azure Cloud Shell is a command-line environment you can access through your web browser. You can use this environment to manage Azure resources, including VMs, storage, and networking. Just like you do when using the Azure CLI or Azure PowerShell. Because Microsoft manages Cloud Shell, you always have access to the most recent versions of the Azure CLI and PowerShell modules right from any browser. You don't have to worry about keeping modules up to date. With Cloud Shell, you just open your browser and sign in. Just like that, you have access to a command-line environment fully connected with your account's permissions and the resources to which you have access. All that works in an infrastructure that's compliant with double encryption at rest by default. You don't need to take any further action! Azure Cloud Shell also provides cloud storage to persist files such as SSH keys, scripts, and more.",How does Azure Cloud Shell address the needs of an IT admin working remotely?,"Azure Cloud Shell allows IT admins to manage Azure resources from any device with a web browser, eliminating the need for their work laptop. This flexibility is beneficial for performing operations on cloud resources using any available device, such as a friend's laptop or a smartphone. The environment provides the most recent versions of Azure CLI and PowerShell modules, allowing seamless management of resources without worrying about software updates."
"Learning objectives

By the end of this module, you're able to:

Describe Azure Cloud Shell and the functionality it provides. Determine whether Azure Cloud Shell meets the needs of your organization. Recognize how to use Azure Cloud Shell and persist files for multiple sessions. 1- Introduction

Azure Cloud Shell is a browser-accessible command-line experience for managing Azure resources. It provides the flexibility of choosing the shell experience that best suits the way you work, either Bash or PowerShell. Traditionally, to interact with Azure resources via command-line, you need to install the necessary components into your local computer (PC, Mac, Linux). With Cloud Shell, you have an authenticated, interactive shell that isn't part of a local machine. You're an IT admin for Contoso Corporation, responsible for the cloud infrastructure on which the company hosts its applications. These applications use different cloud resources, such as Azure VMs, Azure blob storage, Azure networking, and others. On many occasions, you're asked to perform operations on these cloud resources at moments when you’re not using your work laptop. In some cases, you have a friend’s laptop, a smartphone, or another personal PC. This module explains what Azure Cloud Shell does, how it works, and when you should choose to use Cloud Shell as a solution to meet your organization's needs. Learning objectives
In this module, you'll:

Describe Azure Cloud Shell and the functionality it provides. Determine whether Cloud Shell meets the needs of your organization. Recognize how to use Cloud Shell and persist files for multiple sessions. Next unit: What is Azure Cloud Shell? 2- What is Azure Cloud Shell? Azure Cloud Shell is a command-line environment you can access through your web browser. You can use this environment to manage Azure resources, including VMs, storage, and networking. Just like you do when using the Azure CLI or Azure PowerShell. Because Microsoft manages Cloud Shell, you always have access to the most recent versions of the Azure CLI and PowerShell modules right from any browser. You don't have to worry about keeping modules up to date. With Cloud Shell, you just open your browser and sign in. Just like that, you have access to a command-line environment fully connected with your account's permissions and the resources to which you have access. All that works in an infrastructure that's compliant with double encryption at rest by default. You don't need to take any further action! Azure Cloud Shell also provides cloud storage to persist files such as SSH keys, scripts, and more.",What are the advantages of using Azure Cloud Shell compared to traditional local installations?,"The main advantages of using Azure Cloud Shell over traditional local installations include the elimination of the need for local installations of command-line tools, access to the latest versions of Azure CLI and PowerShell without manual updates, and the ability to manage resources from any browser on any device. Additionally, Cloud Shell offers cloud storage for persisting files across sessions, making it more convenient for users who work from multiple locations or devices."
"This functionality lets you access important files in between sessions and with different machines. Finally, you can use the Cloud Shell editor to make changes to files, such as scripts, that are saved into this cloud storage directly from the Cloud Shell interface. Next unit: How does Azure Cloud Shell work? 3- How does Azure Cloud Shell work? As an IT admin for Contoso Corporation, you're frequently on-call to perform administrative tasks and resolve workload disruptions to resources in your organization's Azure subscriptions. When visiting a family member during a weekend that you're on call, the development team notifies you of a problem with an Azure virtual machine (VM). The VM became nonresponsive during scheduled maintenance for the upgrade of an application that runs on it. Because the developers weren't granted access to the underlying Azure virtual machine hosting infrastructure, they're only able to remotely access the VM when it's operating normally. So, you're being called to diagnose and remediate the problem. Since you're visiting family, you don’t have access to your administrative workstation and diagnostic scripts. You do have access to a laptop with an internet browser. Using the laptop, you browse to the Azure portal, authenticate against your organization’s Azure subscription, open Azure Cloud Shell, mount an Azure File Share, access your diagnostic scripts, and diagnose and remediate the problems with the VM, returning it to operation. Access Cloud Shell
You have a few different options for accessing Azure Cloud Shell:

From a direct link: https://shell.azure.com

A screenshot of Cloud Shell accessed directly from a link. From the Azure portal

A screenshot of Cloud Shell accessed from Azure portal. From code snippets when accessing Microsoft Learn:

A screenshot of Cloud Shell accessed from code snippets. When you open a Cloud Shell session, a temporary host is allocated to your session. This VM is preconfigured with the latest versions of PowerShell and Bash. You can then select the command-line experience you want to use:

A screenshot of how to choose a command-line experience in a Cloud Shell session. After you select the shell experience you want to use, you can start managing your Azure resources:

A screenshot of how to use Cloud Shell to manage Azure resources. Cloud Shell sessions terminate after 20 minutes of inactivity. When a session terminates, files on your CloudDrive are persisted, but you need to start a new session to access the Cloud Shell environment. Access your own scripts and files
When using Cloud Shell, you might also need to run scripts or use files for different actions.",How can Azure Cloud Shell be accessed for managing Azure resources remotely?,"Azure Cloud Shell can be accessed remotely through several methods, including a direct link (https://shell.azure.com), from the Azure portal, or from code snippets when accessing Microsoft Learn. Each method provides a way to open a Cloud Shell session where a temporary host with preconfigured PowerShell and Bash is allocated for managing Azure resources."
"This functionality lets you access important files in between sessions and with different machines. Finally, you can use the Cloud Shell editor to make changes to files, such as scripts, that are saved into this cloud storage directly from the Cloud Shell interface. Next unit: How does Azure Cloud Shell work? 3- How does Azure Cloud Shell work? As an IT admin for Contoso Corporation, you're frequently on-call to perform administrative tasks and resolve workload disruptions to resources in your organization's Azure subscriptions. When visiting a family member during a weekend that you're on call, the development team notifies you of a problem with an Azure virtual machine (VM). The VM became nonresponsive during scheduled maintenance for the upgrade of an application that runs on it. Because the developers weren't granted access to the underlying Azure virtual machine hosting infrastructure, they're only able to remotely access the VM when it's operating normally. So, you're being called to diagnose and remediate the problem. Since you're visiting family, you don’t have access to your administrative workstation and diagnostic scripts. You do have access to a laptop with an internet browser. Using the laptop, you browse to the Azure portal, authenticate against your organization’s Azure subscription, open Azure Cloud Shell, mount an Azure File Share, access your diagnostic scripts, and diagnose and remediate the problems with the VM, returning it to operation. Access Cloud Shell
You have a few different options for accessing Azure Cloud Shell:

From a direct link: https://shell.azure.com

A screenshot of Cloud Shell accessed directly from a link. From the Azure portal

A screenshot of Cloud Shell accessed from Azure portal. From code snippets when accessing Microsoft Learn:

A screenshot of Cloud Shell accessed from code snippets. When you open a Cloud Shell session, a temporary host is allocated to your session. This VM is preconfigured with the latest versions of PowerShell and Bash. You can then select the command-line experience you want to use:

A screenshot of how to choose a command-line experience in a Cloud Shell session. After you select the shell experience you want to use, you can start managing your Azure resources:

A screenshot of how to use Cloud Shell to manage Azure resources. Cloud Shell sessions terminate after 20 minutes of inactivity. When a session terminates, files on your CloudDrive are persisted, but you need to start a new session to access the Cloud Shell environment. Access your own scripts and files
When using Cloud Shell, you might also need to run scripts or use files for different actions.",What are the benefits of using Azure Cloud Shell for IT administrators who are frequently on-call?,"Azure Cloud Shell benefits IT administrators who are frequently on-call by allowing them to perform administrative tasks and resolve issues without needing access to their regular workstation. It provides a convenient way to access important files and scripts from any location with an internet connection, enabling quick diagnosis and remediation of problems, such as nonresponsive virtual machines, using a web browser."
"This functionality lets you access important files in between sessions and with different machines. Finally, you can use the Cloud Shell editor to make changes to files, such as scripts, that are saved into this cloud storage directly from the Cloud Shell interface. Next unit: How does Azure Cloud Shell work? 3- How does Azure Cloud Shell work? As an IT admin for Contoso Corporation, you're frequently on-call to perform administrative tasks and resolve workload disruptions to resources in your organization's Azure subscriptions. When visiting a family member during a weekend that you're on call, the development team notifies you of a problem with an Azure virtual machine (VM). The VM became nonresponsive during scheduled maintenance for the upgrade of an application that runs on it. Because the developers weren't granted access to the underlying Azure virtual machine hosting infrastructure, they're only able to remotely access the VM when it's operating normally. So, you're being called to diagnose and remediate the problem. Since you're visiting family, you don’t have access to your administrative workstation and diagnostic scripts. You do have access to a laptop with an internet browser. Using the laptop, you browse to the Azure portal, authenticate against your organization’s Azure subscription, open Azure Cloud Shell, mount an Azure File Share, access your diagnostic scripts, and diagnose and remediate the problems with the VM, returning it to operation. Access Cloud Shell
You have a few different options for accessing Azure Cloud Shell:

From a direct link: https://shell.azure.com

A screenshot of Cloud Shell accessed directly from a link. From the Azure portal

A screenshot of Cloud Shell accessed from Azure portal. From code snippets when accessing Microsoft Learn:

A screenshot of Cloud Shell accessed from code snippets. When you open a Cloud Shell session, a temporary host is allocated to your session. This VM is preconfigured with the latest versions of PowerShell and Bash. You can then select the command-line experience you want to use:

A screenshot of how to choose a command-line experience in a Cloud Shell session. After you select the shell experience you want to use, you can start managing your Azure resources:

A screenshot of how to use Cloud Shell to manage Azure resources. Cloud Shell sessions terminate after 20 minutes of inactivity. When a session terminates, files on your CloudDrive are persisted, but you need to start a new session to access the Cloud Shell environment. Access your own scripts and files
When using Cloud Shell, you might also need to run scripts or use files for different actions.",What happens to your files and session when Azure Cloud Shell terminates due to inactivity?,"When an Azure Cloud Shell session terminates after 20 minutes of inactivity, the files on your CloudDrive are persisted. However, to access the Cloud Shell environment again, you need to start a new session. This ensures that your scripts and files remain available for future use even if the session ends."
"You can persist files on Cloud Shell by using the Azure CloudDrive:

A screenshot of how to access CloudDrive in a Cloud Shell session. After uploading files, you can interact with them as you would in a regular PowerShell or Bash session:

A screenshot of how to manage files in CloudDrive. Now that your file resides on CloudDrive, you can close the session and open another session on a different device and still access the same file. Cloud Shell also lets you map an Azure Storage File Share, which is tied to a specific region. Access to an Azure File Share lets you work with the contents of that share through Cloud Shell. If you need to edit scripts hosted on the CloudDrive or File Share, you can use the Cloud Shell editor. Select the curly brackets {} icon on the browser and open the file you want to edit, or use the command code and specify the filename; for example:

Bash

Copy
code temp.txt
A screenshot of how to access the Cloud Shell editor mode. Cloud Shell tools
If you need to manage resources (such as Docker containers or Kubernetes Clusters) or want to use non-Microsoft tools (such as Ansible and Terraform) in Cloud Shell, the Cloud Shell session comes with these add-ons already preconfigured. Here’s a list of all add-ons available to you within a Cloud Shell session:

Category	Name
Linux tools	bash
zsh
sh
tmux
dig
Azure tools	Azure CLI and Azure classic CLI
AzCopy
Azure Functions CLI
Service Fabric CLI
Batch Shipyard
blobxfer
Text editors	code (Cloud Shell editor)
vim
nano
emacs
Source control	git
Build tools	make
maven
npm
pip
Containers	Docker Machine
Kubectl
Helm
DC/OS CLI
Databases	MySQL client
PostgreSql client
sqlcmd Utility
mssql-scripter
Other	iPython Client
Cloud Foundry CLI
Terraform
Ansible
Chef InSpec
Puppet Bolt
HashiCorp Packer
Office 365 CLI

Next unit: When should you use Azure Cloud Shell? 4- When should you use Azure Cloud Shell? As an IT Admin for Contoso Corporation, you need alternatives to interact with Azure resources from the command line even when not using your default administrative device. You can use Azure Cloud Shell to:

Open a secure command-line session from any browser-based device. Interact with Azure resources without the need to install plug-ins or add-ons to your device.",How can files be persisted in Azure Cloud Shell?,"Files can be persisted in Azure Cloud Shell by using the Azure CloudDrive. Once files are uploaded, they can be accessed and interacted with as in a regular PowerShell or Bash session. CloudDrive allows access to files across different sessions and devices."
"You can persist files on Cloud Shell by using the Azure CloudDrive:

A screenshot of how to access CloudDrive in a Cloud Shell session. After uploading files, you can interact with them as you would in a regular PowerShell or Bash session:

A screenshot of how to manage files in CloudDrive. Now that your file resides on CloudDrive, you can close the session and open another session on a different device and still access the same file. Cloud Shell also lets you map an Azure Storage File Share, which is tied to a specific region. Access to an Azure File Share lets you work with the contents of that share through Cloud Shell. If you need to edit scripts hosted on the CloudDrive or File Share, you can use the Cloud Shell editor. Select the curly brackets {} icon on the browser and open the file you want to edit, or use the command code and specify the filename; for example:

Bash

Copy
code temp.txt
A screenshot of how to access the Cloud Shell editor mode. Cloud Shell tools
If you need to manage resources (such as Docker containers or Kubernetes Clusters) or want to use non-Microsoft tools (such as Ansible and Terraform) in Cloud Shell, the Cloud Shell session comes with these add-ons already preconfigured. Here’s a list of all add-ons available to you within a Cloud Shell session:

Category	Name
Linux tools	bash
zsh
sh
tmux
dig
Azure tools	Azure CLI and Azure classic CLI
AzCopy
Azure Functions CLI
Service Fabric CLI
Batch Shipyard
blobxfer
Text editors	code (Cloud Shell editor)
vim
nano
emacs
Source control	git
Build tools	make
maven
npm
pip
Containers	Docker Machine
Kubectl
Helm
DC/OS CLI
Databases	MySQL client
PostgreSql client
sqlcmd Utility
mssql-scripter
Other	iPython Client
Cloud Foundry CLI
Terraform
Ansible
Chef InSpec
Puppet Bolt
HashiCorp Packer
Office 365 CLI

Next unit: When should you use Azure Cloud Shell? 4- When should you use Azure Cloud Shell? As an IT Admin for Contoso Corporation, you need alternatives to interact with Azure resources from the command line even when not using your default administrative device. You can use Azure Cloud Shell to:

Open a secure command-line session from any browser-based device. Interact with Azure resources without the need to install plug-ins or add-ons to your device.",What additional capabilities does Azure Cloud Shell provide for script editing and management?,"Azure Cloud Shell allows script editing and management through the Cloud Shell editor, which can be accessed by selecting the curly brackets {} icon or using the command 'code' followed by the filename. This feature enables users to edit scripts hosted on CloudDrive or Azure File Share."
"You can persist files on Cloud Shell by using the Azure CloudDrive:

A screenshot of how to access CloudDrive in a Cloud Shell session. After uploading files, you can interact with them as you would in a regular PowerShell or Bash session:

A screenshot of how to manage files in CloudDrive. Now that your file resides on CloudDrive, you can close the session and open another session on a different device and still access the same file. Cloud Shell also lets you map an Azure Storage File Share, which is tied to a specific region. Access to an Azure File Share lets you work with the contents of that share through Cloud Shell. If you need to edit scripts hosted on the CloudDrive or File Share, you can use the Cloud Shell editor. Select the curly brackets {} icon on the browser and open the file you want to edit, or use the command code and specify the filename; for example:

Bash

Copy
code temp.txt
A screenshot of how to access the Cloud Shell editor mode. Cloud Shell tools
If you need to manage resources (such as Docker containers or Kubernetes Clusters) or want to use non-Microsoft tools (such as Ansible and Terraform) in Cloud Shell, the Cloud Shell session comes with these add-ons already preconfigured. Here’s a list of all add-ons available to you within a Cloud Shell session:

Category	Name
Linux tools	bash
zsh
sh
tmux
dig
Azure tools	Azure CLI and Azure classic CLI
AzCopy
Azure Functions CLI
Service Fabric CLI
Batch Shipyard
blobxfer
Text editors	code (Cloud Shell editor)
vim
nano
emacs
Source control	git
Build tools	make
maven
npm
pip
Containers	Docker Machine
Kubectl
Helm
DC/OS CLI
Databases	MySQL client
PostgreSql client
sqlcmd Utility
mssql-scripter
Other	iPython Client
Cloud Foundry CLI
Terraform
Ansible
Chef InSpec
Puppet Bolt
HashiCorp Packer
Office 365 CLI

Next unit: When should you use Azure Cloud Shell? 4- When should you use Azure Cloud Shell? As an IT Admin for Contoso Corporation, you need alternatives to interact with Azure resources from the command line even when not using your default administrative device. You can use Azure Cloud Shell to:

Open a secure command-line session from any browser-based device. Interact with Azure resources without the need to install plug-ins or add-ons to your device.",What preconfigured tools and add-ons are available in Azure Cloud Shell for managing resources and development tasks?,"Azure Cloud Shell comes preconfigured with various tools and add-ons, including Linux tools like bash and tmux, Azure tools like Azure CLI, text editors such as vim and nano, source control with git, build tools like maven and npm, container management tools such as Docker Machine and Kubectl, database clients, and other utilities like Terraform and Ansible."
"Persist files between sessions for later use. Use either Bash or PowerShell, whichever you prefer, to manage Azure resources. Edit files (such as scripts) via the Cloud Shell editor. You shouldn't use Azure Cloud Shell if:

You intend to leave a session open for more than 20 minutes for long running scripts or activities. In these cases, your session is disconnected without warning, and the current state is lost. You need admin permissions, such as sudo access, from within the Azure CLI or PowerShell environment. You need to install tools that aren't supported in the limited Cloud Shell environment, but instead require an environment such as a custom virtual machine or container. You need storage from different regions. You might need to back up and synchronize this content since only one region can have the storage allocated to Azure Cloud Shell. You need to open multiple sessions at the same time. Azure Cloud Shell allows only one instance at time and isn't suitable for concurrent work across multiple subscriptions or tenants. Next unit: Knowledge check

Check your knowledge

1. Which of these methods can you use to access Azure Cloud Shell from a computer running Windows 11? Install Windows Subsystem for Linux and make an SSH connection to Azure. Make a Remote Desktop Protocol connection to Azure. Use the Microsoft Edge Browser to log into an Azure Subscription. 2. You want to store a script that you constantly use for operations on Azure resources. This script needs to be rapidly available when you open a new Azure Cloud Shell session. Which of these procedures should you use? Upload the script to your CloudDrive on an Azure Cloud Shell session. Create a new script and store it on an Azure Storage Blob. Use Cloud Shell editor to create and edit the script you want to use. 3. You have a script stored on the Cloud Shell storage. You constantly use this script for resource management, but you need to perform small changes to it. Which of these solutions is the best way to handle the situation? Download the script from the Azure Cloud Shell session, edit the script, and upload it back before using it. Push the script to GitHub and run it from the Azure Cloud Shell session. Use the Cloud Shell editor to make the necessary changes and save it directly on the CloudDrive. Summary

Azure Cloud Shell is a browser-accessible command-line experience for managing Azure resources. Rather than having to configure an Azure CLI or PowerShell session from your workstation, you can access Cloud Shell on any standard, compliant browser.",What are the limitations of using Azure Cloud Shell for long-running activities?,"Azure Cloud Shell disconnects sessions without warning after 20 minutes of inactivity, which can result in the loss of the current state for long-running scripts or activities."
"Persist files between sessions for later use. Use either Bash or PowerShell, whichever you prefer, to manage Azure resources. Edit files (such as scripts) via the Cloud Shell editor. You shouldn't use Azure Cloud Shell if:

You intend to leave a session open for more than 20 minutes for long running scripts or activities. In these cases, your session is disconnected without warning, and the current state is lost. You need admin permissions, such as sudo access, from within the Azure CLI or PowerShell environment. You need to install tools that aren't supported in the limited Cloud Shell environment, but instead require an environment such as a custom virtual machine or container. You need storage from different regions. You might need to back up and synchronize this content since only one region can have the storage allocated to Azure Cloud Shell. You need to open multiple sessions at the same time. Azure Cloud Shell allows only one instance at time and isn't suitable for concurrent work across multiple subscriptions or tenants. Next unit: Knowledge check

Check your knowledge

1. Which of these methods can you use to access Azure Cloud Shell from a computer running Windows 11? Install Windows Subsystem for Linux and make an SSH connection to Azure. Make a Remote Desktop Protocol connection to Azure. Use the Microsoft Edge Browser to log into an Azure Subscription. 2. You want to store a script that you constantly use for operations on Azure resources. This script needs to be rapidly available when you open a new Azure Cloud Shell session. Which of these procedures should you use? Upload the script to your CloudDrive on an Azure Cloud Shell session. Create a new script and store it on an Azure Storage Blob. Use Cloud Shell editor to create and edit the script you want to use. 3. You have a script stored on the Cloud Shell storage. You constantly use this script for resource management, but you need to perform small changes to it. Which of these solutions is the best way to handle the situation? Download the script from the Azure Cloud Shell session, edit the script, and upload it back before using it. Push the script to GitHub and run it from the Azure Cloud Shell session. Use the Cloud Shell editor to make the necessary changes and save it directly on the CloudDrive. Summary

Azure Cloud Shell is a browser-accessible command-line experience for managing Azure resources. Rather than having to configure an Azure CLI or PowerShell session from your workstation, you can access Cloud Shell on any standard, compliant browser.",Why might someone need to use a custom virtual machine instead of Azure Cloud Shell?,Someone might need to use a custom virtual machine if they require admin permissions like sudo access or need to install tools that aren't supported in the limited Cloud Shell environment.
"Persist files between sessions for later use. Use either Bash or PowerShell, whichever you prefer, to manage Azure resources. Edit files (such as scripts) via the Cloud Shell editor. You shouldn't use Azure Cloud Shell if:

You intend to leave a session open for more than 20 minutes for long running scripts or activities. In these cases, your session is disconnected without warning, and the current state is lost. You need admin permissions, such as sudo access, from within the Azure CLI or PowerShell environment. You need to install tools that aren't supported in the limited Cloud Shell environment, but instead require an environment such as a custom virtual machine or container. You need storage from different regions. You might need to back up and synchronize this content since only one region can have the storage allocated to Azure Cloud Shell. You need to open multiple sessions at the same time. Azure Cloud Shell allows only one instance at time and isn't suitable for concurrent work across multiple subscriptions or tenants. Next unit: Knowledge check

Check your knowledge

1. Which of these methods can you use to access Azure Cloud Shell from a computer running Windows 11? Install Windows Subsystem for Linux and make an SSH connection to Azure. Make a Remote Desktop Protocol connection to Azure. Use the Microsoft Edge Browser to log into an Azure Subscription. 2. You want to store a script that you constantly use for operations on Azure resources. This script needs to be rapidly available when you open a new Azure Cloud Shell session. Which of these procedures should you use? Upload the script to your CloudDrive on an Azure Cloud Shell session. Create a new script and store it on an Azure Storage Blob. Use Cloud Shell editor to create and edit the script you want to use. 3. You have a script stored on the Cloud Shell storage. You constantly use this script for resource management, but you need to perform small changes to it. Which of these solutions is the best way to handle the situation? Download the script from the Azure Cloud Shell session, edit the script, and upload it back before using it. Push the script to GitHub and run it from the Azure Cloud Shell session. Use the Cloud Shell editor to make the necessary changes and save it directly on the CloudDrive. Summary

Azure Cloud Shell is a browser-accessible command-line experience for managing Azure resources. Rather than having to configure an Azure CLI or PowerShell session from your workstation, you can access Cloud Shell on any standard, compliant browser.",How can you ensure a script is readily available in a new Azure Cloud Shell session?,"You can ensure a script is readily available by uploading it to your CloudDrive on an Azure Cloud Shell session, allowing it to be rapidly accessible when you start a new session."
"Cloud Shell provides the flexibility of choosing the shell experience that best suits the way you work, allowing you to work either in Bash or PowerShell, right from the browser. Cloud Shell also provides you with the mechanisms to persist files between sessions, and provides access to a minimalist version of the Visual Studio Code editor for more complex operations. Point 3: Introduction to Bash

Use Bash to manage IT infrastructure. Learning objectives
In this module, you will:

Learn what shells are and what Bash is. Learn about the syntax of Bash commands. Learn about important Bash commands, such as ls, cat, and ps. Learn how to use I/O operators to redirect input and output. Learn how to update a server's operating system. Learn how to find and terminate rogue processes. Learn how to use Bash to filter Azure CLI output. 1- Introduction

Imagine that you just started a new job as a system administrator (sysadmin) at Northwind, a high-frequency trading (HFT) firm that runs Windows on its client computers and Linux on its server computers. Computers are the lifeblood of the company, and you need to learn more about how to manage Linux boxes. It's time to skill up! Bash is the standard shell scripting language for Linux. Let's learn the basics of Bash, starting with the syntax and commonly used commands, like ls and cat. Learning objectives
In this module, you will:

Learn what shells are and what Bash is
Learn about the syntax of Bash commands
Learn about important Bash commands, such as ls, cat, and ps
Learn how to use I/O operators to redirect input and output
Learn how to update a server's operating system
Learn how to find and terminate rogue processes
Learn how to use Bash to filter Azure CLI output

Next unit: What is Bash? 2- What is Bash? Bash is a vital tool for managing Linux machines. The name is short for ""Bourne Again Shell."" A shell is a program that commands the operating system to perform actions. You can enter commands in a console on your computer and run the commands directly, or you can use scripts to run batches of commands. Shells like PowerShell and Bash give system administrators the power and precision they need for fine-tuned control of the computers they're responsible for. There are other Linux shells, including csh and zsh, but Bash has become the de facto Linux standard. That's because Bash is compatible with Unix's first serious shell, the Bourne shell, also known as sh.",What are the benefits of using Cloud Shell for system administrators?,"Cloud Shell offers system administrators the flexibility of choosing between Bash and PowerShell directly from the browser, allowing for a familiar working environment. It supports file persistence across sessions and provides access to a minimalist version of the Visual Studio Code editor for performing more complex operations."
"Cloud Shell provides the flexibility of choosing the shell experience that best suits the way you work, allowing you to work either in Bash or PowerShell, right from the browser. Cloud Shell also provides you with the mechanisms to persist files between sessions, and provides access to a minimalist version of the Visual Studio Code editor for more complex operations. Point 3: Introduction to Bash

Use Bash to manage IT infrastructure. Learning objectives
In this module, you will:

Learn what shells are and what Bash is. Learn about the syntax of Bash commands. Learn about important Bash commands, such as ls, cat, and ps. Learn how to use I/O operators to redirect input and output. Learn how to update a server's operating system. Learn how to find and terminate rogue processes. Learn how to use Bash to filter Azure CLI output. 1- Introduction

Imagine that you just started a new job as a system administrator (sysadmin) at Northwind, a high-frequency trading (HFT) firm that runs Windows on its client computers and Linux on its server computers. Computers are the lifeblood of the company, and you need to learn more about how to manage Linux boxes. It's time to skill up! Bash is the standard shell scripting language for Linux. Let's learn the basics of Bash, starting with the syntax and commonly used commands, like ls and cat. Learning objectives
In this module, you will:

Learn what shells are and what Bash is
Learn about the syntax of Bash commands
Learn about important Bash commands, such as ls, cat, and ps
Learn how to use I/O operators to redirect input and output
Learn how to update a server's operating system
Learn how to find and terminate rogue processes
Learn how to use Bash to filter Azure CLI output

Next unit: What is Bash? 2- What is Bash? Bash is a vital tool for managing Linux machines. The name is short for ""Bourne Again Shell."" A shell is a program that commands the operating system to perform actions. You can enter commands in a console on your computer and run the commands directly, or you can use scripts to run batches of commands. Shells like PowerShell and Bash give system administrators the power and precision they need for fine-tuned control of the computers they're responsible for. There are other Linux shells, including csh and zsh, but Bash has become the de facto Linux standard. That's because Bash is compatible with Unix's first serious shell, the Bourne shell, also known as sh.",Why is Bash considered the standard shell scripting language for Linux?,"Bash is considered the standard shell scripting language for Linux because it is compatible with Unix's first serious shell, the Bourne shell (sh). It has become the de facto standard due to its wide adoption, familiarity, and powerful scripting capabilities. Additionally, it provides system administrators with the ability to manage Linux machines effectively."
"Cloud Shell provides the flexibility of choosing the shell experience that best suits the way you work, allowing you to work either in Bash or PowerShell, right from the browser. Cloud Shell also provides you with the mechanisms to persist files between sessions, and provides access to a minimalist version of the Visual Studio Code editor for more complex operations. Point 3: Introduction to Bash

Use Bash to manage IT infrastructure. Learning objectives
In this module, you will:

Learn what shells are and what Bash is. Learn about the syntax of Bash commands. Learn about important Bash commands, such as ls, cat, and ps. Learn how to use I/O operators to redirect input and output. Learn how to update a server's operating system. Learn how to find and terminate rogue processes. Learn how to use Bash to filter Azure CLI output. 1- Introduction

Imagine that you just started a new job as a system administrator (sysadmin) at Northwind, a high-frequency trading (HFT) firm that runs Windows on its client computers and Linux on its server computers. Computers are the lifeblood of the company, and you need to learn more about how to manage Linux boxes. It's time to skill up! Bash is the standard shell scripting language for Linux. Let's learn the basics of Bash, starting with the syntax and commonly used commands, like ls and cat. Learning objectives
In this module, you will:

Learn what shells are and what Bash is
Learn about the syntax of Bash commands
Learn about important Bash commands, such as ls, cat, and ps
Learn how to use I/O operators to redirect input and output
Learn how to update a server's operating system
Learn how to find and terminate rogue processes
Learn how to use Bash to filter Azure CLI output

Next unit: What is Bash? 2- What is Bash? Bash is a vital tool for managing Linux machines. The name is short for ""Bourne Again Shell."" A shell is a program that commands the operating system to perform actions. You can enter commands in a console on your computer and run the commands directly, or you can use scripts to run batches of commands. Shells like PowerShell and Bash give system administrators the power and precision they need for fine-tuned control of the computers they're responsible for. There are other Linux shells, including csh and zsh, but Bash has become the de facto Linux standard. That's because Bash is compatible with Unix's first serious shell, the Bourne shell, also known as sh.",What are some of the key learning objectives for a sysadmin at Northwind when it comes to using Bash?,"Some key learning objectives for a sysadmin at Northwind when learning Bash include understanding what shells are and what Bash is, learning the syntax of Bash commands, mastering important Bash commands such as ls, cat, and ps, using I/O operators for input and output redirection, updating a server's operating system, finding and terminating rogue processes, and using Bash to filter Azure CLI output."
"Bash incorporates the best features of its predecessors. But Bash also has some fine features of its own, including built-in commands and the ability to invoke external programs. One reason for Bash's success is its simplicity. Bash, like the rest of Linux, is based on the Unix design philosophy. As Peter Salus summarized in his book A Quarter Century of Unix, three of the ""big ideas"" embodied in Unix are:

Programs do one thing and do it well
Programs work together
Programs use text streams as the universal interface
The last part is key to understanding how Bash works. In Unix and Linux, everything is a file. That means you can use the same commands without worrying about whether the I/O stream — the input and output — comes from a keyboard, a disk file, a socket, a pipe, or another I/O abstraction. Let's learn the basics of Bash, starting with the syntax and commonly used commands, like ls and cat. Next unit: Bash fundamentals

3- Bash fundamentals

An understanding of Bash starts with an understanding of Bash syntax. After you know the syntax, you can apply it to every Bash command you run. The full syntax for a Bash command is:

Bash

Copy
command [options] [arguments]
Bash treats the first string it encounters as a command. The following command uses Bash's ls (for ""list"") command to display the contents of the current working directory:

Bash

Copy
ls
Bash commands are often accompanied by arguments. For example, you can include a path name in an ls command to list the contents of another directory:

Bash

Copy
ls /etc
Most Bash commands have options for modifying how they work. Options, also called flags, give a command more specific instructions. As an example, files and directories whose names begin with a period are hidden from the user and are not displayed by ls. However, you can include the -a (for ""all"") flag in an ls command and see everything in the target directory:

Bash

Copy
ls -a /etc
You can even combine flags for brevity. For example, rather than enter ls -a -l /etc to show all files and directories in Linux's /etc directory in long form, you can enter this instead:

Bash

Copy
ls -al /etc
Bash is concise. It's sometimes remarkable (and a point of pride among Bash aficionados) how much you can accomplish with a single command.",What are some key features of Bash that contribute to its effectiveness as a command-line interface?,"Bash incorporates the best features of its predecessors and adds its own fine features, such as built-in commands and the ability to invoke external programs. Its success is largely due to its simplicity and adherence to the Unix design philosophy, which emphasizes programs doing one thing well, working together, and using text streams as a universal interface."
"Bash incorporates the best features of its predecessors. But Bash also has some fine features of its own, including built-in commands and the ability to invoke external programs. One reason for Bash's success is its simplicity. Bash, like the rest of Linux, is based on the Unix design philosophy. As Peter Salus summarized in his book A Quarter Century of Unix, three of the ""big ideas"" embodied in Unix are:

Programs do one thing and do it well
Programs work together
Programs use text streams as the universal interface
The last part is key to understanding how Bash works. In Unix and Linux, everything is a file. That means you can use the same commands without worrying about whether the I/O stream — the input and output — comes from a keyboard, a disk file, a socket, a pipe, or another I/O abstraction. Let's learn the basics of Bash, starting with the syntax and commonly used commands, like ls and cat. Next unit: Bash fundamentals

3- Bash fundamentals

An understanding of Bash starts with an understanding of Bash syntax. After you know the syntax, you can apply it to every Bash command you run. The full syntax for a Bash command is:

Bash

Copy
command [options] [arguments]
Bash treats the first string it encounters as a command. The following command uses Bash's ls (for ""list"") command to display the contents of the current working directory:

Bash

Copy
ls
Bash commands are often accompanied by arguments. For example, you can include a path name in an ls command to list the contents of another directory:

Bash

Copy
ls /etc
Most Bash commands have options for modifying how they work. Options, also called flags, give a command more specific instructions. As an example, files and directories whose names begin with a period are hidden from the user and are not displayed by ls. However, you can include the -a (for ""all"") flag in an ls command and see everything in the target directory:

Bash

Copy
ls -a /etc
You can even combine flags for brevity. For example, rather than enter ls -a -l /etc to show all files and directories in Linux's /etc directory in long form, you can enter this instead:

Bash

Copy
ls -al /etc
Bash is concise. It's sometimes remarkable (and a point of pride among Bash aficionados) how much you can accomplish with a single command.",How does Bash utilize the Unix design philosophy in its command execution?,"Bash follows the Unix design philosophy by treating everything as a file, allowing the same commands to be used regardless of whether the input and output come from a keyboard, a disk file, a socket, a pipe, or another I/O abstraction. This consistent interface simplifies command execution and integration with other programs."
"Bash incorporates the best features of its predecessors. But Bash also has some fine features of its own, including built-in commands and the ability to invoke external programs. One reason for Bash's success is its simplicity. Bash, like the rest of Linux, is based on the Unix design philosophy. As Peter Salus summarized in his book A Quarter Century of Unix, three of the ""big ideas"" embodied in Unix are:

Programs do one thing and do it well
Programs work together
Programs use text streams as the universal interface
The last part is key to understanding how Bash works. In Unix and Linux, everything is a file. That means you can use the same commands without worrying about whether the I/O stream — the input and output — comes from a keyboard, a disk file, a socket, a pipe, or another I/O abstraction. Let's learn the basics of Bash, starting with the syntax and commonly used commands, like ls and cat. Next unit: Bash fundamentals

3- Bash fundamentals

An understanding of Bash starts with an understanding of Bash syntax. After you know the syntax, you can apply it to every Bash command you run. The full syntax for a Bash command is:

Bash

Copy
command [options] [arguments]
Bash treats the first string it encounters as a command. The following command uses Bash's ls (for ""list"") command to display the contents of the current working directory:

Bash

Copy
ls
Bash commands are often accompanied by arguments. For example, you can include a path name in an ls command to list the contents of another directory:

Bash

Copy
ls /etc
Most Bash commands have options for modifying how they work. Options, also called flags, give a command more specific instructions. As an example, files and directories whose names begin with a period are hidden from the user and are not displayed by ls. However, you can include the -a (for ""all"") flag in an ls command and see everything in the target directory:

Bash

Copy
ls -a /etc
You can even combine flags for brevity. For example, rather than enter ls -a -l /etc to show all files and directories in Linux's /etc directory in long form, you can enter this instead:

Bash

Copy
ls -al /etc
Bash is concise. It's sometimes remarkable (and a point of pride among Bash aficionados) how much you can accomplish with a single command.",How can options and arguments be used to modify the behavior of Bash commands?,"In Bash, commands can be modified using options, also known as flags, and arguments. Options provide specific instructions to alter a command's behavior, while arguments specify additional parameters, such as file paths. For example, the ls command can use the -a flag to show all files, including hidden ones, and can be combined with other flags, like -l, for a concise command like ls -al /etc."
"Get help
Which options and arguments can be used, or must be used, varies from command to command. Fortunately, Bash documentation is built into the operating system. Help is never more than a command away. To learn about the options for a command, use the man (for ""manual"") command. For instance, to see all the options for the mkdir (""make directory"") command, do this:

Bash

Copy
man mkdir
man will be your best friend as you learn Bash. man is how you find the information you need to understand how any command works. Most Bash and Linux commands support the --help option. This shows a description of the command's syntax and options. To demonstrate, enter mkdir --help. The output will look something like this:

Output

Copy
Usage: mkdir [OPTION]... DIRECTORY... Create the DIRECTORY(ies), if they do not already exist. Mandatory arguments to long options are mandatory for short options too. -m, --mode=MODE   set file mode (as in chmod), not a=rwx - umask
  -p, --parents     no error if existing, make parent directories as needed
  -v, --verbose     print a message for each created directory
  -Z                   set SELinux security context of each created directory
                         to the default type
      --context[=CTX]  like -Z, or if CTX is specified then set the SELinux
                         or SMACK security context to CTX
      --help     display this help and exit
      --version  output version information and exit
    
GNU coreutils online help: <http://www.gnu.org/software/coreutils/>
Report mkdir translation bugs to <http://translationproject.org/team/>
Full documentation at: <http://www.gnu.org/software/coreutils/mkdir>
or available locally via: info '(coreutils) mkdir invocation'
Help obtained this way is typically more concise than help obtained with man. Use wildcards
Wildcards are symbols that represent one or more characters in Bash commands. The most frequently used wildcard is the asterisk. It represents zero characters or a sequence of characters. Suppose your current directory contains hundreds of image files, but you only want to see the PNG files; the ones whose file names end with .png. Here's the command to list only those files:

Bash

Copy
ls *.png
 Note

Linux has no formal concept of a file-name extension as other operating systems do.",What is the purpose of using the 'man' command in Bash?,"The 'man' command in Bash is used to access the manual pages of commands, which provide detailed information about the command's options, arguments, and usage. It is an essential tool for understanding how specific commands work."
"Get help
Which options and arguments can be used, or must be used, varies from command to command. Fortunately, Bash documentation is built into the operating system. Help is never more than a command away. To learn about the options for a command, use the man (for ""manual"") command. For instance, to see all the options for the mkdir (""make directory"") command, do this:

Bash

Copy
man mkdir
man will be your best friend as you learn Bash. man is how you find the information you need to understand how any command works. Most Bash and Linux commands support the --help option. This shows a description of the command's syntax and options. To demonstrate, enter mkdir --help. The output will look something like this:

Output

Copy
Usage: mkdir [OPTION]... DIRECTORY... Create the DIRECTORY(ies), if they do not already exist. Mandatory arguments to long options are mandatory for short options too. -m, --mode=MODE   set file mode (as in chmod), not a=rwx - umask
  -p, --parents     no error if existing, make parent directories as needed
  -v, --verbose     print a message for each created directory
  -Z                   set SELinux security context of each created directory
                         to the default type
      --context[=CTX]  like -Z, or if CTX is specified then set the SELinux
                         or SMACK security context to CTX
      --help     display this help and exit
      --version  output version information and exit
    
GNU coreutils online help: <http://www.gnu.org/software/coreutils/>
Report mkdir translation bugs to <http://translationproject.org/team/>
Full documentation at: <http://www.gnu.org/software/coreutils/mkdir>
or available locally via: info '(coreutils) mkdir invocation'
Help obtained this way is typically more concise than help obtained with man. Use wildcards
Wildcards are symbols that represent one or more characters in Bash commands. The most frequently used wildcard is the asterisk. It represents zero characters or a sequence of characters. Suppose your current directory contains hundreds of image files, but you only want to see the PNG files; the ones whose file names end with .png. Here's the command to list only those files:

Bash

Copy
ls *.png
 Note

Linux has no formal concept of a file-name extension as other operating systems do.",How can you quickly view the options and syntax for a command in Bash without using the 'man' command?,You can quickly view the options and syntax for a command in Bash by using the '--help' option with the command. This displays a brief description of the command's syntax and available options.
"Get help
Which options and arguments can be used, or must be used, varies from command to command. Fortunately, Bash documentation is built into the operating system. Help is never more than a command away. To learn about the options for a command, use the man (for ""manual"") command. For instance, to see all the options for the mkdir (""make directory"") command, do this:

Bash

Copy
man mkdir
man will be your best friend as you learn Bash. man is how you find the information you need to understand how any command works. Most Bash and Linux commands support the --help option. This shows a description of the command's syntax and options. To demonstrate, enter mkdir --help. The output will look something like this:

Output

Copy
Usage: mkdir [OPTION]... DIRECTORY... Create the DIRECTORY(ies), if they do not already exist. Mandatory arguments to long options are mandatory for short options too. -m, --mode=MODE   set file mode (as in chmod), not a=rwx - umask
  -p, --parents     no error if existing, make parent directories as needed
  -v, --verbose     print a message for each created directory
  -Z                   set SELinux security context of each created directory
                         to the default type
      --context[=CTX]  like -Z, or if CTX is specified then set the SELinux
                         or SMACK security context to CTX
      --help     display this help and exit
      --version  output version information and exit
    
GNU coreutils online help: <http://www.gnu.org/software/coreutils/>
Report mkdir translation bugs to <http://translationproject.org/team/>
Full documentation at: <http://www.gnu.org/software/coreutils/mkdir>
or available locally via: info '(coreutils) mkdir invocation'
Help obtained this way is typically more concise than help obtained with man. Use wildcards
Wildcards are symbols that represent one or more characters in Bash commands. The most frequently used wildcard is the asterisk. It represents zero characters or a sequence of characters. Suppose your current directory contains hundreds of image files, but you only want to see the PNG files; the ones whose file names end with .png. Here's the command to list only those files:

Bash

Copy
ls *.png
 Note

Linux has no formal concept of a file-name extension as other operating systems do.","What role do wildcards play in Bash commands, and provide an example of their usage?","Wildcards in Bash commands are symbols that represent one or more characters, allowing for pattern matching. The most commonly used wildcard is the asterisk (*), which represents zero or more characters. For example, to list only PNG files in a directory, you can use the command 'ls *.png'."
"This doesn't mean that PNG files won't have a .png extension. It simply means Linux attaches no special significance to the fact that the file names end with .png. Now let's say the current directory also contains JPEG files. Some end in .jpg, while others end in .jpeg. Here's one way to list all the JPEG files:

Bash

Copy
ls *.jpg *.jpeg
And here is another:

Bash

Copy
ls *.jp*g
The * wildcard matches on zero or more characters, but the ? wildcard represents a single character. If the current directory contains files named 0001.jpg, 0002.jpg, and so on through 0009.jpg, the following command lists them all:

Bash

Copy
ls 000?.jpg
Yet another way to use wildcards to filter output is to use square brackets, which denote groups of characters. The following command lists all the files in the current directory whose names contain a period immediately followed a lowercase J or P. It lists all the .jpg, .jpeg, and .png files, but not .gif files:

Bash

Copy
ls *. [jp]*
In Linux, file names and the commands that operate upon them are case-sensitive. So to list all the files in the current directory whose names contain periods followed by an uppercase or lowercase J or P, you could enter this:

Bash

Copy
ls *. [jpJP]*
Expressions in square brackets can represent ranges of characters. For example, the following command lists all the files in the current directory whose names begin with a lowercase letter:

Bash

Copy
ls [a-z]*
This command, by contrast, lists all the files in the current directory whose names begin with an uppercase letter:

Bash

Copy
ls [A-Z]*
And this one lists all the files in the current directory whose names begin with a lowercase or uppercase letter:

Bash

Copy
ls [a-zA-Z]*
Based on all this, can you guess what the following commands will do? Bash

Copy
ls [0-9]*
ls *[0-9]*
ls *[0-9]
If you need to use one of the wildcard characters as an ordinary character, you make it literal or ""escape it"" by prefacing it with a backslash.",What is the significance of wildcards like * and ? in Linux file commands?,"In Linux, wildcards are used to match patterns in file names. The * wildcard matches zero or more characters, allowing users to list files with various extensions or patterns. The ? wildcard, on the other hand, represents a single character, making it useful for matching files with a specific number of characters in a certain position."
"This doesn't mean that PNG files won't have a .png extension. It simply means Linux attaches no special significance to the fact that the file names end with .png. Now let's say the current directory also contains JPEG files. Some end in .jpg, while others end in .jpeg. Here's one way to list all the JPEG files:

Bash

Copy
ls *.jpg *.jpeg
And here is another:

Bash

Copy
ls *.jp*g
The * wildcard matches on zero or more characters, but the ? wildcard represents a single character. If the current directory contains files named 0001.jpg, 0002.jpg, and so on through 0009.jpg, the following command lists them all:

Bash

Copy
ls 000?.jpg
Yet another way to use wildcards to filter output is to use square brackets, which denote groups of characters. The following command lists all the files in the current directory whose names contain a period immediately followed a lowercase J or P. It lists all the .jpg, .jpeg, and .png files, but not .gif files:

Bash

Copy
ls *. [jp]*
In Linux, file names and the commands that operate upon them are case-sensitive. So to list all the files in the current directory whose names contain periods followed by an uppercase or lowercase J or P, you could enter this:

Bash

Copy
ls *. [jpJP]*
Expressions in square brackets can represent ranges of characters. For example, the following command lists all the files in the current directory whose names begin with a lowercase letter:

Bash

Copy
ls [a-z]*
This command, by contrast, lists all the files in the current directory whose names begin with an uppercase letter:

Bash

Copy
ls [A-Z]*
And this one lists all the files in the current directory whose names begin with a lowercase or uppercase letter:

Bash

Copy
ls [a-zA-Z]*
Based on all this, can you guess what the following commands will do? Bash

Copy
ls [0-9]*
ls *[0-9]*
ls *[0-9]
If you need to use one of the wildcard characters as an ordinary character, you make it literal or ""escape it"" by prefacing it with a backslash.",How can you list all files in a directory that begin with an uppercase letter using Linux commands?,"To list all files in a directory that begin with an uppercase letter, you can use the command `ls [A-Z]*`. This command uses the square brackets to specify a range of characters, in this case, any uppercase letter from A to Z, followed by any sequence of characters."
"This doesn't mean that PNG files won't have a .png extension. It simply means Linux attaches no special significance to the fact that the file names end with .png. Now let's say the current directory also contains JPEG files. Some end in .jpg, while others end in .jpeg. Here's one way to list all the JPEG files:

Bash

Copy
ls *.jpg *.jpeg
And here is another:

Bash

Copy
ls *.jp*g
The * wildcard matches on zero or more characters, but the ? wildcard represents a single character. If the current directory contains files named 0001.jpg, 0002.jpg, and so on through 0009.jpg, the following command lists them all:

Bash

Copy
ls 000?.jpg
Yet another way to use wildcards to filter output is to use square brackets, which denote groups of characters. The following command lists all the files in the current directory whose names contain a period immediately followed a lowercase J or P. It lists all the .jpg, .jpeg, and .png files, but not .gif files:

Bash

Copy
ls *. [jp]*
In Linux, file names and the commands that operate upon them are case-sensitive. So to list all the files in the current directory whose names contain periods followed by an uppercase or lowercase J or P, you could enter this:

Bash

Copy
ls *. [jpJP]*
Expressions in square brackets can represent ranges of characters. For example, the following command lists all the files in the current directory whose names begin with a lowercase letter:

Bash

Copy
ls [a-z]*
This command, by contrast, lists all the files in the current directory whose names begin with an uppercase letter:

Bash

Copy
ls [A-Z]*
And this one lists all the files in the current directory whose names begin with a lowercase or uppercase letter:

Bash

Copy
ls [a-zA-Z]*
Based on all this, can you guess what the following commands will do? Bash

Copy
ls [0-9]*
ls *[0-9]*
ls *[0-9]
If you need to use one of the wildcard characters as an ordinary character, you make it literal or ""escape it"" by prefacing it with a backslash.",How can you escape a wildcard character in a Linux command to treat it as a literal character?,"To escape a wildcard character in a Linux command and treat it as a literal character, you prefix it with a backslash. For example, to include an asterisk (*) in a file name pattern as a literal character rather than a wildcard, you would write \*."
"So, if for some reason you had an asterisk as part of a file name — something you should never do intentionally — you could search for it by using a command such as:

Bash

Copy
$ ls *\**

Next unit: Bash commands and operators

4- Bash commands and operators

Every shell language has its most-used commands. Let's start building your Bash repertoire by examining the most commonly used commands. Bash commands
Let's look at common Bash commands and how to use them. ls command
ls lists the contents of your current directory or the directory specified in an argument to the command. By itself, it lists the files and directories in the current directory:

Bash

Copy
ls
Files and directories whose names begin with a period are hidden by default. To include these items in a directory listing, use an -a flag:

Bash

Copy
ls -a
To get even more information about the files and directories in the current directory, use an -l flag:

Bash

Copy
ls -l
Here's some sample output from a directory that contains a handful of JPEGs and PNGs and a subdirectory named gifs:

Output

Copy
-rw-rw-r-- 1 azureuser azureuser  473774 Jun 13 15:38 0001.png
-rw-rw-r-- 1 azureuser azureuser 1557965 Jun 13 14:43 0002.jpg
-rw-rw-r-- 1 azureuser azureuser  473774 Mar 26 09:21 0003.png
-rw-rw-r-- 1 azureuser azureuser 4193680 Jun 13 09:40 0004.jpg
-rw-rw-r-- 1 azureuser azureuser  423325 Jun 10 12:53 0005.jpg
-rw-rw-r-- 1 azureuser azureuser 2278001 Jun 12 04:21 0006.jpg
-rw-rw-r-- 1 azureuser azureuser 1220517 Jun 13 14:44 0007.jpg
drwxrwxr-x 2 azureuser azureuser    4096 Jun 13 20:16 gifs
Each line provides detailed information about the corresponding file or directory. That information includes the permissions assigned to it, its owner, its size in bytes, the last time it was modified, and the file or directory name.",How would you search for a file with an asterisk in its name using Bash?,"You can search for a file with an asterisk in its name using the command `ls *\*`. The backslash is used to escape the asterisk, allowing it to be treated as a literal character rather than a wildcard."
"So, if for some reason you had an asterisk as part of a file name — something you should never do intentionally — you could search for it by using a command such as:

Bash

Copy
$ ls *\**

Next unit: Bash commands and operators

4- Bash commands and operators

Every shell language has its most-used commands. Let's start building your Bash repertoire by examining the most commonly used commands. Bash commands
Let's look at common Bash commands and how to use them. ls command
ls lists the contents of your current directory or the directory specified in an argument to the command. By itself, it lists the files and directories in the current directory:

Bash

Copy
ls
Files and directories whose names begin with a period are hidden by default. To include these items in a directory listing, use an -a flag:

Bash

Copy
ls -a
To get even more information about the files and directories in the current directory, use an -l flag:

Bash

Copy
ls -l
Here's some sample output from a directory that contains a handful of JPEGs and PNGs and a subdirectory named gifs:

Output

Copy
-rw-rw-r-- 1 azureuser azureuser  473774 Jun 13 15:38 0001.png
-rw-rw-r-- 1 azureuser azureuser 1557965 Jun 13 14:43 0002.jpg
-rw-rw-r-- 1 azureuser azureuser  473774 Mar 26 09:21 0003.png
-rw-rw-r-- 1 azureuser azureuser 4193680 Jun 13 09:40 0004.jpg
-rw-rw-r-- 1 azureuser azureuser  423325 Jun 10 12:53 0005.jpg
-rw-rw-r-- 1 azureuser azureuser 2278001 Jun 12 04:21 0006.jpg
-rw-rw-r-- 1 azureuser azureuser 1220517 Jun 13 14:44 0007.jpg
drwxrwxr-x 2 azureuser azureuser    4096 Jun 13 20:16 gifs
Each line provides detailed information about the corresponding file or directory. That information includes the permissions assigned to it, its owner, its size in bytes, the last time it was modified, and the file or directory name.",What is the purpose of the `-a` flag when using the `ls` command in Bash?,The `-a` flag is used with the `ls` command to include hidden files and directories in the directory listing. These are files and directories whose names begin with a period.
"So, if for some reason you had an asterisk as part of a file name — something you should never do intentionally — you could search for it by using a command such as:

Bash

Copy
$ ls *\**

Next unit: Bash commands and operators

4- Bash commands and operators

Every shell language has its most-used commands. Let's start building your Bash repertoire by examining the most commonly used commands. Bash commands
Let's look at common Bash commands and how to use them. ls command
ls lists the contents of your current directory or the directory specified in an argument to the command. By itself, it lists the files and directories in the current directory:

Bash

Copy
ls
Files and directories whose names begin with a period are hidden by default. To include these items in a directory listing, use an -a flag:

Bash

Copy
ls -a
To get even more information about the files and directories in the current directory, use an -l flag:

Bash

Copy
ls -l
Here's some sample output from a directory that contains a handful of JPEGs and PNGs and a subdirectory named gifs:

Output

Copy
-rw-rw-r-- 1 azureuser azureuser  473774 Jun 13 15:38 0001.png
-rw-rw-r-- 1 azureuser azureuser 1557965 Jun 13 14:43 0002.jpg
-rw-rw-r-- 1 azureuser azureuser  473774 Mar 26 09:21 0003.png
-rw-rw-r-- 1 azureuser azureuser 4193680 Jun 13 09:40 0004.jpg
-rw-rw-r-- 1 azureuser azureuser  423325 Jun 10 12:53 0005.jpg
-rw-rw-r-- 1 azureuser azureuser 2278001 Jun 12 04:21 0006.jpg
-rw-rw-r-- 1 azureuser azureuser 1220517 Jun 13 14:44 0007.jpg
drwxrwxr-x 2 azureuser azureuser    4096 Jun 13 20:16 gifs
Each line provides detailed information about the corresponding file or directory. That information includes the permissions assigned to it, its owner, its size in bytes, the last time it was modified, and the file or directory name.",What detailed information is provided by the `ls -l` command in Bash?,"The `ls -l` command provides detailed information about files and directories, including permissions, owner, file size in bytes, last modification time, and the file or directory name."
"cat command
Suppose you want to see what's inside a file. You can use the cat command for that. The output won't make much sense unless the file is a text file. The following command shows the contents of the os-release file stored in the /etc directory:

Bash

Copy
cat /etc/os-release
This is a useful command because it tells you which Linux distribution you're running:

Output

Copy
NAME=""Ubuntu""
VERSION=""18.04.2 LTS (Bionic Beaver)""
ID=ubuntu
ID_LIKE=debian
PRETTY_NAME=""Ubuntu 18.04.2 LTS""
VERSION_ID=""18.04""
HOME_URL=""https://www.ubuntu.com/""
SUPPORT_URL=""https://help.ubuntu.com/""
BUG_REPORT_URL=""https://bugs.launchpad.net/ubuntu/""
PRIVACY_POLICY_URL=""https://www.ubuntu.com/legal/terms-and-policies/privacy-policy""
VERSION_CODENAME=bionic
UBUNTU_CODENAME=bionic
The /etc directory is a special one in Linux. It contains system-configuration files. You don't want to delete any files from this directory unless you know what you're doing. sudo command
Some Bash commands can only be run by the root user; a system administrator or superuser. If you try one of these commands without sufficient privileges, it fails. For example, only users logged in as a superuser can use cat to display the contents of /etc/at.deny:

Bash

Copy
cat /etc/at.deny
at.deny is a special file that determines who can use other Bash commands to submit jobs for later execution. You don't want to run as root most of the time; it's too dangerous. To run commands that require admin privilege without logging in as a superuser, you'll preface the commands with sudo:

Bash

Copy
sudo cat /etc/at.deny
sudo stands for ""superuser do."" When you use it, you're telling the shell that for this one command, you're acting with the root-user level of permission. cd, mkdir, and rmdir commands
cd stands for ""change directory,"" and it does exactly what the name suggests: it changes the current directory to another directory. It enables you to move from one directory to another just like its counterpart in Windows.","What is the purpose of the cat command in Linux, and when might its output not be useful?","The cat command in Linux is used to display the contents of a file. Its output might not be useful if the file is not a text file, as the contents may not be easily readable or make sense."
"cat command
Suppose you want to see what's inside a file. You can use the cat command for that. The output won't make much sense unless the file is a text file. The following command shows the contents of the os-release file stored in the /etc directory:

Bash

Copy
cat /etc/os-release
This is a useful command because it tells you which Linux distribution you're running:

Output

Copy
NAME=""Ubuntu""
VERSION=""18.04.2 LTS (Bionic Beaver)""
ID=ubuntu
ID_LIKE=debian
PRETTY_NAME=""Ubuntu 18.04.2 LTS""
VERSION_ID=""18.04""
HOME_URL=""https://www.ubuntu.com/""
SUPPORT_URL=""https://help.ubuntu.com/""
BUG_REPORT_URL=""https://bugs.launchpad.net/ubuntu/""
PRIVACY_POLICY_URL=""https://www.ubuntu.com/legal/terms-and-policies/privacy-policy""
VERSION_CODENAME=bionic
UBUNTU_CODENAME=bionic
The /etc directory is a special one in Linux. It contains system-configuration files. You don't want to delete any files from this directory unless you know what you're doing. sudo command
Some Bash commands can only be run by the root user; a system administrator or superuser. If you try one of these commands without sufficient privileges, it fails. For example, only users logged in as a superuser can use cat to display the contents of /etc/at.deny:

Bash

Copy
cat /etc/at.deny
at.deny is a special file that determines who can use other Bash commands to submit jobs for later execution. You don't want to run as root most of the time; it's too dangerous. To run commands that require admin privilege without logging in as a superuser, you'll preface the commands with sudo:

Bash

Copy
sudo cat /etc/at.deny
sudo stands for ""superuser do."" When you use it, you're telling the shell that for this one command, you're acting with the root-user level of permission. cd, mkdir, and rmdir commands
cd stands for ""change directory,"" and it does exactly what the name suggests: it changes the current directory to another directory. It enables you to move from one directory to another just like its counterpart in Windows.",Why is it important to be cautious when working with files in the /etc directory in Linux?,"The /etc directory in Linux contains system-configuration files, which are crucial for the system's operation. Deleting or modifying these files without proper knowledge can lead to system instability or other issues."
"cat command
Suppose you want to see what's inside a file. You can use the cat command for that. The output won't make much sense unless the file is a text file. The following command shows the contents of the os-release file stored in the /etc directory:

Bash

Copy
cat /etc/os-release
This is a useful command because it tells you which Linux distribution you're running:

Output

Copy
NAME=""Ubuntu""
VERSION=""18.04.2 LTS (Bionic Beaver)""
ID=ubuntu
ID_LIKE=debian
PRETTY_NAME=""Ubuntu 18.04.2 LTS""
VERSION_ID=""18.04""
HOME_URL=""https://www.ubuntu.com/""
SUPPORT_URL=""https://help.ubuntu.com/""
BUG_REPORT_URL=""https://bugs.launchpad.net/ubuntu/""
PRIVACY_POLICY_URL=""https://www.ubuntu.com/legal/terms-and-policies/privacy-policy""
VERSION_CODENAME=bionic
UBUNTU_CODENAME=bionic
The /etc directory is a special one in Linux. It contains system-configuration files. You don't want to delete any files from this directory unless you know what you're doing. sudo command
Some Bash commands can only be run by the root user; a system administrator or superuser. If you try one of these commands without sufficient privileges, it fails. For example, only users logged in as a superuser can use cat to display the contents of /etc/at.deny:

Bash

Copy
cat /etc/at.deny
at.deny is a special file that determines who can use other Bash commands to submit jobs for later execution. You don't want to run as root most of the time; it's too dangerous. To run commands that require admin privilege without logging in as a superuser, you'll preface the commands with sudo:

Bash

Copy
sudo cat /etc/at.deny
sudo stands for ""superuser do."" When you use it, you're telling the shell that for this one command, you're acting with the root-user level of permission. cd, mkdir, and rmdir commands
cd stands for ""change directory,"" and it does exactly what the name suggests: it changes the current directory to another directory. It enables you to move from one directory to another just like its counterpart in Windows.",How does the sudo command enhance the functionality of Linux commands that require administrative privileges?,The sudo command allows a user to run commands with root-user level permissions for a single command without logging in as a superuser. This provides the necessary administrative privileges while minimizing the risk associated with operating as a root user.
"The following command changes to a subdirectory of the current directory named orders:

Bash

Copy
cd orders
You can move up a directory by specifying .. as the directory name:

Bash

Copy
cd .. This command changes to your home directory; the one you land in when you first log in:

Bash

Copy
cd ~
You can create directories by using the mkdir command. The following command creates a subdirectory named orders in the current working directory:

Bash

Copy
mkdir orders
If you want to create a subdirectory and another subdirectory under it with one command, use the --parents flag:

Bash

Copy
mkdir --parents orders/2019
The rmdir command deletes (removes) a directory, but only if it's empty. If it's not empty, you'll get a warning instead. Fortunately, you can use the rm command to delete directories that aren't empty in combination with the -r (recursive) flag. The command would then look like so, rm -r.

rm command
The rm command is short for ""remove."" As you'd expect, rm deletes files. So this command puts an end to 0001.jpg:

Bash

Copy
rm 0001.jpg
And this command deletes all the files in the current directory:

Bash

Copy
rm *
Be wary of rm. It's a dangerous command. Running rm with a -i flag lets you think before you delete:

Bash

Copy
rm -i *
Make it a habit to include -i in every rm command, and you might avoid falling victim to one of Linux's biggest blunders. The dreaded rm -rf / command deletes every file on an entire drive. It works by recursively deleting all the subdirectories of root and their subdirectories. The -f (for ""force"") flag compounds the problem by suppressing prompts. Don't do this. If you want to delete a subdirectory named orders that isn't empty, you can use the rm command this way:

Bash

Copy
rm -r orders
This deletes the orders subdirectory and everything in it, including other subdirectories. cp command
The cp command copies not just files, but entire directories (and subdirectories) if you want. To make a copy of 0001.jpg named 0002.jpg, use this command:

Bash

Copy
cp 0001.jpg 0002.jpg
If 0002.jpg already exists, Bash silently replaces it.",How can you change to your home directory using a command in Bash?,You can change to your home directory using the command `cd ~`.
"The following command changes to a subdirectory of the current directory named orders:

Bash

Copy
cd orders
You can move up a directory by specifying .. as the directory name:

Bash

Copy
cd .. This command changes to your home directory; the one you land in when you first log in:

Bash

Copy
cd ~
You can create directories by using the mkdir command. The following command creates a subdirectory named orders in the current working directory:

Bash

Copy
mkdir orders
If you want to create a subdirectory and another subdirectory under it with one command, use the --parents flag:

Bash

Copy
mkdir --parents orders/2019
The rmdir command deletes (removes) a directory, but only if it's empty. If it's not empty, you'll get a warning instead. Fortunately, you can use the rm command to delete directories that aren't empty in combination with the -r (recursive) flag. The command would then look like so, rm -r.

rm command
The rm command is short for ""remove."" As you'd expect, rm deletes files. So this command puts an end to 0001.jpg:

Bash

Copy
rm 0001.jpg
And this command deletes all the files in the current directory:

Bash

Copy
rm *
Be wary of rm. It's a dangerous command. Running rm with a -i flag lets you think before you delete:

Bash

Copy
rm -i *
Make it a habit to include -i in every rm command, and you might avoid falling victim to one of Linux's biggest blunders. The dreaded rm -rf / command deletes every file on an entire drive. It works by recursively deleting all the subdirectories of root and their subdirectories. The -f (for ""force"") flag compounds the problem by suppressing prompts. Don't do this. If you want to delete a subdirectory named orders that isn't empty, you can use the rm command this way:

Bash

Copy
rm -r orders
This deletes the orders subdirectory and everything in it, including other subdirectories. cp command
The cp command copies not just files, but entire directories (and subdirectories) if you want. To make a copy of 0001.jpg named 0002.jpg, use this command:

Bash

Copy
cp 0001.jpg 0002.jpg
If 0002.jpg already exists, Bash silently replaces it.",What is the purpose of the --parents flag when using the mkdir command?,The --parents flag allows you to create a subdirectory and another subdirectory under it with one command.
"The following command changes to a subdirectory of the current directory named orders:

Bash

Copy
cd orders
You can move up a directory by specifying .. as the directory name:

Bash

Copy
cd .. This command changes to your home directory; the one you land in when you first log in:

Bash

Copy
cd ~
You can create directories by using the mkdir command. The following command creates a subdirectory named orders in the current working directory:

Bash

Copy
mkdir orders
If you want to create a subdirectory and another subdirectory under it with one command, use the --parents flag:

Bash

Copy
mkdir --parents orders/2019
The rmdir command deletes (removes) a directory, but only if it's empty. If it's not empty, you'll get a warning instead. Fortunately, you can use the rm command to delete directories that aren't empty in combination with the -r (recursive) flag. The command would then look like so, rm -r.

rm command
The rm command is short for ""remove."" As you'd expect, rm deletes files. So this command puts an end to 0001.jpg:

Bash

Copy
rm 0001.jpg
And this command deletes all the files in the current directory:

Bash

Copy
rm *
Be wary of rm. It's a dangerous command. Running rm with a -i flag lets you think before you delete:

Bash

Copy
rm -i *
Make it a habit to include -i in every rm command, and you might avoid falling victim to one of Linux's biggest blunders. The dreaded rm -rf / command deletes every file on an entire drive. It works by recursively deleting all the subdirectories of root and their subdirectories. The -f (for ""force"") flag compounds the problem by suppressing prompts. Don't do this. If you want to delete a subdirectory named orders that isn't empty, you can use the rm command this way:

Bash

Copy
rm -r orders
This deletes the orders subdirectory and everything in it, including other subdirectories. cp command
The cp command copies not just files, but entire directories (and subdirectories) if you want. To make a copy of 0001.jpg named 0002.jpg, use this command:

Bash

Copy
cp 0001.jpg 0002.jpg
If 0002.jpg already exists, Bash silently replaces it.",What is the difference between using `rm` and `rm -i` commands?,"The `rm` command deletes files or directories without any prompts, while `rm -i` prompts you for confirmation before each deletion, allowing you to think before you delete."
"That's great if it's what you intended, but not so wonderful if you didn't realize you were about to overwrite the old version. Fortunately, if you use the -i (for ""interactive"") flag, Bash warns you before deleting existing files. This is much safer:

Bash

Copy
cp -i 0001.jpg 0002.jpg
Of course, you can use wildcards to copy several files at once. To copy all the files in the current directory to a subdirectory named photos, do this:

Bash

Copy
cp * photos
To copy all the files in a subdirectory named photos into a subdirectory named images, do this:

Bash

Copy
cp photos/* images
This assumes that the images directory already exists. If it doesn't, you can create it and copy the contents of the photos directory by using this command:

Bash

Copy
cp -r photos images
The -r stands for ""recursive."" An added benefit of the -r flag is that if photos contains subdirectories of its own, they too are copied to the images directory. ps command
The ps command gives you a snapshot of all the currently running processes. By itself, with no arguments, it shows all your shell processes; in other words, not much. But it's a different story when you include a -e flag:

Bash

Copy
ps -e
-e lists all running processes, and there are typically many of them. For a more comprehensive look at what processes are running in the system, use the -ef flag:

Bash

Copy
ps -ef 
This flag shows the names of all the running processes, their process identification numbers (PIDs), the PIDs of their parents (PPIDs), and when they began (STIME). It also shows what terminal, if any, they're attached to (TTY), how much CPU time they've racked up (TIME), and their full path names. Here is an abbreviated example:


Copy
UID         PID   PPID  C STIME TTY          TIME CMD
root          1      0  0 13:35 ? 00:00:03 /sbin/init
root          2      0  0 13:35 ? 00:00:00 [kthreadd]
root          3      2  0 13:35 ? 00:00:00 [rcu_gp]
root          4      2  0 13:35 ?",What is the purpose of using the -i flag when copying files with the cp command in Bash?,"The -i (interactive) flag is used to prompt the user before overwriting an existing file, providing a warning and an opportunity to prevent accidental data loss."
"That's great if it's what you intended, but not so wonderful if you didn't realize you were about to overwrite the old version. Fortunately, if you use the -i (for ""interactive"") flag, Bash warns you before deleting existing files. This is much safer:

Bash

Copy
cp -i 0001.jpg 0002.jpg
Of course, you can use wildcards to copy several files at once. To copy all the files in the current directory to a subdirectory named photos, do this:

Bash

Copy
cp * photos
To copy all the files in a subdirectory named photos into a subdirectory named images, do this:

Bash

Copy
cp photos/* images
This assumes that the images directory already exists. If it doesn't, you can create it and copy the contents of the photos directory by using this command:

Bash

Copy
cp -r photos images
The -r stands for ""recursive."" An added benefit of the -r flag is that if photos contains subdirectories of its own, they too are copied to the images directory. ps command
The ps command gives you a snapshot of all the currently running processes. By itself, with no arguments, it shows all your shell processes; in other words, not much. But it's a different story when you include a -e flag:

Bash

Copy
ps -e
-e lists all running processes, and there are typically many of them. For a more comprehensive look at what processes are running in the system, use the -ef flag:

Bash

Copy
ps -ef 
This flag shows the names of all the running processes, their process identification numbers (PIDs), the PIDs of their parents (PPIDs), and when they began (STIME). It also shows what terminal, if any, they're attached to (TTY), how much CPU time they've racked up (TIME), and their full path names. Here is an abbreviated example:


Copy
UID         PID   PPID  C STIME TTY          TIME CMD
root          1      0  0 13:35 ? 00:00:03 /sbin/init
root          2      0  0 13:35 ? 00:00:00 [kthreadd]
root          3      2  0 13:35 ? 00:00:00 [rcu_gp]
root          4      2  0 13:35 ?","How can you copy all files from one directory to another using the cp command, and what does the -r flag do?","You can copy all files from one directory to another using the cp command with a wildcard, like cp * photos. The -r flag stands for ""recursive"" and is used to copy directories along with their contents, including any subdirectories."
"That's great if it's what you intended, but not so wonderful if you didn't realize you were about to overwrite the old version. Fortunately, if you use the -i (for ""interactive"") flag, Bash warns you before deleting existing files. This is much safer:

Bash

Copy
cp -i 0001.jpg 0002.jpg
Of course, you can use wildcards to copy several files at once. To copy all the files in the current directory to a subdirectory named photos, do this:

Bash

Copy
cp * photos
To copy all the files in a subdirectory named photos into a subdirectory named images, do this:

Bash

Copy
cp photos/* images
This assumes that the images directory already exists. If it doesn't, you can create it and copy the contents of the photos directory by using this command:

Bash

Copy
cp -r photos images
The -r stands for ""recursive."" An added benefit of the -r flag is that if photos contains subdirectories of its own, they too are copied to the images directory. ps command
The ps command gives you a snapshot of all the currently running processes. By itself, with no arguments, it shows all your shell processes; in other words, not much. But it's a different story when you include a -e flag:

Bash

Copy
ps -e
-e lists all running processes, and there are typically many of them. For a more comprehensive look at what processes are running in the system, use the -ef flag:

Bash

Copy
ps -ef 
This flag shows the names of all the running processes, their process identification numbers (PIDs), the PIDs of their parents (PPIDs), and when they began (STIME). It also shows what terminal, if any, they're attached to (TTY), how much CPU time they've racked up (TIME), and their full path names. Here is an abbreviated example:


Copy
UID         PID   PPID  C STIME TTY          TIME CMD
root          1      0  0 13:35 ? 00:00:03 /sbin/init
root          2      0  0 13:35 ? 00:00:00 [kthreadd]
root          3      2  0 13:35 ? 00:00:00 [rcu_gp]
root          4      2  0 13:35 ?",What information does the ps -ef command provide about running processes?,"The ps -ef command provides detailed information about running processes, including their process identification numbers (PIDs), parent PIDs (PPIDs), the start time (STIME), attached terminal (TTY), CPU time used (TIME), and their full command paths (CMD)."
"00:00:00 [rcu_par_gp]
root          5      2  0 13:35 ? 00:00:00 [kworker/0:0-cgr]
root          6      2  0 13:35 ? 00:00:00 [kworker/0:0H-kb]
root          8      2  0 13:35 ? 00:00:00 [mm_percpu_wq]
root          9      2  0 13:35 ? 00:00:01 [ksoftirqd/0]
root         10      2  0 13:35 ? 00:00:02 [rcu_sched]
As an aside, you might find documentation that shows ps being used this way:

Bash

Copy
ps aux
ps aux and ps -ef are the same. This duality traces back to historical differences between POSIX Unix systems (of which Linux is one) and BSD Unix systems (the most common of which is macOS). In the beginning, POSIX used -ef while the BSD required aux. Today, both operating-system families accept either format. This serves as an excellent reminder of why you should look closely at the manual for all Linux commands. Learning Bash is like learning English as a second language. There are many exceptions to the rules. w command
Users come, users go, and sometimes you get users you don't want at all. When an employee leaves to pursue other opportunities, the sysadmin is called upon to ensure that the worker can no longer log in to the company's computer systems. Sysadmins are also expected to know who's logged in, and who shouldn't be. To find out who's on your servers, Linux provides the w (for ""who"") command. It displays information about the users currently on the computer system and those users' activities. w shows user names, their IP addresses, when they logged in, what processes they're currently running, and how much time those processes are consuming. It's a valuable tool for sysadmins. Bash I/O operators
You can do a lot in Linux just by exercising Bash commands and their many options.",What historical differences have led to the duality in using 'ps aux' and 'ps -ef' commands?,"The duality in using 'ps aux' and 'ps -ef' commands traces back to historical differences between POSIX Unix systems, which used '-ef', and BSD Unix systems, which required 'aux'. Today, both operating-system families accept either format."
"00:00:00 [rcu_par_gp]
root          5      2  0 13:35 ? 00:00:00 [kworker/0:0-cgr]
root          6      2  0 13:35 ? 00:00:00 [kworker/0:0H-kb]
root          8      2  0 13:35 ? 00:00:00 [mm_percpu_wq]
root          9      2  0 13:35 ? 00:00:01 [ksoftirqd/0]
root         10      2  0 13:35 ? 00:00:02 [rcu_sched]
As an aside, you might find documentation that shows ps being used this way:

Bash

Copy
ps aux
ps aux and ps -ef are the same. This duality traces back to historical differences between POSIX Unix systems (of which Linux is one) and BSD Unix systems (the most common of which is macOS). In the beginning, POSIX used -ef while the BSD required aux. Today, both operating-system families accept either format. This serves as an excellent reminder of why you should look closely at the manual for all Linux commands. Learning Bash is like learning English as a second language. There are many exceptions to the rules. w command
Users come, users go, and sometimes you get users you don't want at all. When an employee leaves to pursue other opportunities, the sysadmin is called upon to ensure that the worker can no longer log in to the company's computer systems. Sysadmins are also expected to know who's logged in, and who shouldn't be. To find out who's on your servers, Linux provides the w (for ""who"") command. It displays information about the users currently on the computer system and those users' activities. w shows user names, their IP addresses, when they logged in, what processes they're currently running, and how much time those processes are consuming. It's a valuable tool for sysadmins. Bash I/O operators
You can do a lot in Linux just by exercising Bash commands and their many options.",How can a sysadmin find out who is currently logged into the computer systems and what are they doing?,"A sysadmin can use the 'w' command in Linux to find out who is currently logged into the computer systems. It displays information about user names, their IP addresses, when they logged in, what processes they're currently running, and how much time those processes are consuming."
"00:00:00 [rcu_par_gp]
root          5      2  0 13:35 ? 00:00:00 [kworker/0:0-cgr]
root          6      2  0 13:35 ? 00:00:00 [kworker/0:0H-kb]
root          8      2  0 13:35 ? 00:00:00 [mm_percpu_wq]
root          9      2  0 13:35 ? 00:00:01 [ksoftirqd/0]
root         10      2  0 13:35 ? 00:00:02 [rcu_sched]
As an aside, you might find documentation that shows ps being used this way:

Bash

Copy
ps aux
ps aux and ps -ef are the same. This duality traces back to historical differences between POSIX Unix systems (of which Linux is one) and BSD Unix systems (the most common of which is macOS). In the beginning, POSIX used -ef while the BSD required aux. Today, both operating-system families accept either format. This serves as an excellent reminder of why you should look closely at the manual for all Linux commands. Learning Bash is like learning English as a second language. There are many exceptions to the rules. w command
Users come, users go, and sometimes you get users you don't want at all. When an employee leaves to pursue other opportunities, the sysadmin is called upon to ensure that the worker can no longer log in to the company's computer systems. Sysadmins are also expected to know who's logged in, and who shouldn't be. To find out who's on your servers, Linux provides the w (for ""who"") command. It displays information about the users currently on the computer system and those users' activities. w shows user names, their IP addresses, when they logged in, what processes they're currently running, and how much time those processes are consuming. It's a valuable tool for sysadmins. Bash I/O operators
You can do a lot in Linux just by exercising Bash commands and their many options.",Why is it important for sysadmins to monitor user logins and activities on company computer systems?,"It is important for sysadmins to monitor user logins and activities to ensure that unauthorized users do not have access to the company's computer systems, especially when an employee leaves. Monitoring allows sysadmins to maintain security and manage user access effectively."
"But you can really get work done when you combine commands by using I/O operators:

< for redirecting input to a source other than the keyboard
> for redirecting output to destination other than the screen
>> for doing the same, but appending rather than overwriting
| for piping output from one command to the input of another
Suppose you want to list everything in the current directory but capture the output in a file named listing.txt. The following command does just that:

Bash

Copy
ls > listing.txt
If listing.txt already exists, it gets overwritten. If you use the >> operator instead, the output from ls is appended to what's already in listing.txt:

Bash

Copy
ls >> listing.txt
The piping operator is extremely powerful (and often used). It redirects the output of the first command to the input of the second command. Let's say you use cat to display the contents of a large file, but the content scrolls by too quickly for you to read. You can make the output more manageable by piping the results to another command such as more. The following command lists all the currently running processes. But once the screen is full, the output pauses until you select Enter to show the next line:

Bash

Copy
ps -ef | more
You can also pipe output to head to see just the first several lines:

Bash

Copy
ps -ef | head
Or suppose you want to filter the output to include only the lines that contain the word ""daemon."" One way to do that is by piping the output from ps to Linux's useful grep tool:

Bash

Copy
ps -ef | grep daemon
The output might look like this:

Output

Copy
azureus+  52463  50702  0 23:28 pts/0    00:00:00 grep --color=auto deamon
azureuser@bash-vm:~$ ps -ef | grep daemon
root        449      1  0 13:35 ? 00:00:17 /usr/lib/linux-tools/4.18.0-1018-azure/hv_kvp_daemon -n
root        988      1  0 13:35 ? 00:00:00 /usr/lib/accountsservice/accounts-daemon
message+   1002      1  0 13:35 ?",What is the purpose of using the '>' and '>>' operators in command line operations?,"The '>' operator is used to redirect output to a destination other than the screen, such as a file, and it overwrites any existing content in the file. The '>>' operator also redirects output to a destination but appends the output to the existing content instead of overwriting it."
"But you can really get work done when you combine commands by using I/O operators:

< for redirecting input to a source other than the keyboard
> for redirecting output to destination other than the screen
>> for doing the same, but appending rather than overwriting
| for piping output from one command to the input of another
Suppose you want to list everything in the current directory but capture the output in a file named listing.txt. The following command does just that:

Bash

Copy
ls > listing.txt
If listing.txt already exists, it gets overwritten. If you use the >> operator instead, the output from ls is appended to what's already in listing.txt:

Bash

Copy
ls >> listing.txt
The piping operator is extremely powerful (and often used). It redirects the output of the first command to the input of the second command. Let's say you use cat to display the contents of a large file, but the content scrolls by too quickly for you to read. You can make the output more manageable by piping the results to another command such as more. The following command lists all the currently running processes. But once the screen is full, the output pauses until you select Enter to show the next line:

Bash

Copy
ps -ef | more
You can also pipe output to head to see just the first several lines:

Bash

Copy
ps -ef | head
Or suppose you want to filter the output to include only the lines that contain the word ""daemon."" One way to do that is by piping the output from ps to Linux's useful grep tool:

Bash

Copy
ps -ef | grep daemon
The output might look like this:

Output

Copy
azureus+  52463  50702  0 23:28 pts/0    00:00:00 grep --color=auto deamon
azureuser@bash-vm:~$ ps -ef | grep daemon
root        449      1  0 13:35 ? 00:00:17 /usr/lib/linux-tools/4.18.0-1018-azure/hv_kvp_daemon -n
root        988      1  0 13:35 ? 00:00:00 /usr/lib/accountsservice/accounts-daemon
message+   1002      1  0 13:35 ?",How can the pipe operator '|' be utilized to manage large outputs in the command line?,"The pipe operator '|' can be used to redirect the output of one command to the input of another, which is particularly useful for managing large outputs. For example, you can pipe the output to 'more' to pause the display once the screen is full, allowing you to control the flow of information by pressing Enter."
"But you can really get work done when you combine commands by using I/O operators:

< for redirecting input to a source other than the keyboard
> for redirecting output to destination other than the screen
>> for doing the same, but appending rather than overwriting
| for piping output from one command to the input of another
Suppose you want to list everything in the current directory but capture the output in a file named listing.txt. The following command does just that:

Bash

Copy
ls > listing.txt
If listing.txt already exists, it gets overwritten. If you use the >> operator instead, the output from ls is appended to what's already in listing.txt:

Bash

Copy
ls >> listing.txt
The piping operator is extremely powerful (and often used). It redirects the output of the first command to the input of the second command. Let's say you use cat to display the contents of a large file, but the content scrolls by too quickly for you to read. You can make the output more manageable by piping the results to another command such as more. The following command lists all the currently running processes. But once the screen is full, the output pauses until you select Enter to show the next line:

Bash

Copy
ps -ef | more
You can also pipe output to head to see just the first several lines:

Bash

Copy
ps -ef | head
Or suppose you want to filter the output to include only the lines that contain the word ""daemon."" One way to do that is by piping the output from ps to Linux's useful grep tool:

Bash

Copy
ps -ef | grep daemon
The output might look like this:

Output

Copy
azureus+  52463  50702  0 23:28 pts/0    00:00:00 grep --color=auto deamon
azureuser@bash-vm:~$ ps -ef | grep daemon
root        449      1  0 13:35 ? 00:00:17 /usr/lib/linux-tools/4.18.0-1018-azure/hv_kvp_daemon -n
root        988      1  0 13:35 ? 00:00:00 /usr/lib/accountsservice/accounts-daemon
message+   1002      1  0 13:35 ?",How can you filter command line outputs to include only specific lines using Linux commands?,"You can filter command line outputs by piping the output of one command to the 'grep' tool, which searches for lines containing a specific word or pattern. For instance, using 'ps -ef | grep daemon' filters the process list to include only lines containing the word ""daemon."""
"00:00:00 /usr/bin/dbus-daemon --system --address=systemd: --nofork --nopidfile --systemd-activation --syslog-only
daemon     1035      1  0 13:35 ? 00:00:00 /usr/sbin/atd -f
root       1037      1  0 13:35 ? 00:00:00 /usr/bin/python3 -u /usr/sbin/waagent -daemon
root       1039      1  0 13:35 ? 00:00:00 /usr/lib/linux-tools/4.18.0-1018-azure/hv_vss_daemon -n
azureus+  52477  50702  0 23:28 pts/0    00:00:00 grep --color=auto daemon
You can also use files as input. By default, standard input comes from the keyboard, but it too can be redirected. To get input from a file instead of the keyboard, use the < operator. One common sysadmin task is to sort the contents of a file. As the name suggests, sort sorts text in alphabetical order:

Bash

Copy
sort < file.txt
To save the sorted results to a new file, you can redirect input and output:

Bash

Copy
sort < file.txt > sorted_file.txt
You can use I/O operators to chain Linux commands as needed. Consider the following command:

Bash

Copy
cat file.txt | fmt | pr | lpr
The output from cat goes to fmt, the output from fmt goes to pr, and so on. fmt formats the results into a tidy paragraph. pr paginates the results. And lpr sends the paginated output to the printer. All in a single line! Next unit: Exercise - Try Bash

5- Exercise - Try Bash

On your own Linux computer, you can run Bash commands locally. If you have access to Linux servers, you can remote in to them and run Bash commands there. But nobody wants to experiment on a live production system, particularly on their first day at Northwind. In this unit, you'll use Azure Cloud Shell on the right as your Linux terminal. Azure Cloud Shell is a shell you can access through the Azure portal or at https://shell.azure.com. You don't have to install anything on your PC or laptop to use it.",What is the role of I/O operators in chaining Linux commands?,"I/O operators are used to redirect the input and output of commands, allowing multiple commands to be chained together. This enables the output of one command to be used as the input for the next command in the sequence."
"00:00:00 /usr/bin/dbus-daemon --system --address=systemd: --nofork --nopidfile --systemd-activation --syslog-only
daemon     1035      1  0 13:35 ? 00:00:00 /usr/sbin/atd -f
root       1037      1  0 13:35 ? 00:00:00 /usr/bin/python3 -u /usr/sbin/waagent -daemon
root       1039      1  0 13:35 ? 00:00:00 /usr/lib/linux-tools/4.18.0-1018-azure/hv_vss_daemon -n
azureus+  52477  50702  0 23:28 pts/0    00:00:00 grep --color=auto daemon
You can also use files as input. By default, standard input comes from the keyboard, but it too can be redirected. To get input from a file instead of the keyboard, use the < operator. One common sysadmin task is to sort the contents of a file. As the name suggests, sort sorts text in alphabetical order:

Bash

Copy
sort < file.txt
To save the sorted results to a new file, you can redirect input and output:

Bash

Copy
sort < file.txt > sorted_file.txt
You can use I/O operators to chain Linux commands as needed. Consider the following command:

Bash

Copy
cat file.txt | fmt | pr | lpr
The output from cat goes to fmt, the output from fmt goes to pr, and so on. fmt formats the results into a tidy paragraph. pr paginates the results. And lpr sends the paginated output to the printer. All in a single line! Next unit: Exercise - Try Bash

5- Exercise - Try Bash

On your own Linux computer, you can run Bash commands locally. If you have access to Linux servers, you can remote in to them and run Bash commands there. But nobody wants to experiment on a live production system, particularly on their first day at Northwind. In this unit, you'll use Azure Cloud Shell on the right as your Linux terminal. Azure Cloud Shell is a shell you can access through the Azure portal or at https://shell.azure.com. You don't have to install anything on your PC or laptop to use it.",How can you sort the contents of a file and save the results to a new file using Bash commands?,"You can sort the contents of a file using the `sort` command with input redirection, and save the sorted results to a new file with output redirection. The command would be `sort < file.txt > sorted_file.txt`."
"00:00:00 /usr/bin/dbus-daemon --system --address=systemd: --nofork --nopidfile --systemd-activation --syslog-only
daemon     1035      1  0 13:35 ? 00:00:00 /usr/sbin/atd -f
root       1037      1  0 13:35 ? 00:00:00 /usr/bin/python3 -u /usr/sbin/waagent -daemon
root       1039      1  0 13:35 ? 00:00:00 /usr/lib/linux-tools/4.18.0-1018-azure/hv_vss_daemon -n
azureus+  52477  50702  0 23:28 pts/0    00:00:00 grep --color=auto daemon
You can also use files as input. By default, standard input comes from the keyboard, but it too can be redirected. To get input from a file instead of the keyboard, use the < operator. One common sysadmin task is to sort the contents of a file. As the name suggests, sort sorts text in alphabetical order:

Bash

Copy
sort < file.txt
To save the sorted results to a new file, you can redirect input and output:

Bash

Copy
sort < file.txt > sorted_file.txt
You can use I/O operators to chain Linux commands as needed. Consider the following command:

Bash

Copy
cat file.txt | fmt | pr | lpr
The output from cat goes to fmt, the output from fmt goes to pr, and so on. fmt formats the results into a tidy paragraph. pr paginates the results. And lpr sends the paginated output to the printer. All in a single line! Next unit: Exercise - Try Bash

5- Exercise - Try Bash

On your own Linux computer, you can run Bash commands locally. If you have access to Linux servers, you can remote in to them and run Bash commands there. But nobody wants to experiment on a live production system, particularly on their first day at Northwind. In this unit, you'll use Azure Cloud Shell on the right as your Linux terminal. Azure Cloud Shell is a shell you can access through the Azure portal or at https://shell.azure.com. You don't have to install anything on your PC or laptop to use it.",What is Azure Cloud Shell and how can it be accessed?,Azure Cloud Shell is a shell environment that can be accessed through the Azure portal or at https://shell.azure.com. It allows users to run Bash commands without needing to install anything on their PC or laptop.
"Familiarize yourself with Cloud Shell
First, let's explore what's in Cloud Shell by using the Bash commands we've learned. Use the ls command to list all files and subdirectories in the current directory:

Bash

Copy
ls
You should see output that looks similar to this:

Output

Copy
yourname@Azure:~$ ls
clouddrive
clouddrive is a subdirectory of your current directory. It's a mounted file share that persists if you're using Cloud Shell on your own account. Right now, you're using it on the Microsoft Learn sandbox. But wait, what is the current directory? Let's use the pwd command to find out. pwd stands for ""print working directory."" It prints out the long-form path to what directory you're in now. Bash

Copy
pwd
You should see an output like this:

Output

Copy
yourname@Azure:~$ pwd
/home/yourname
This output means that you're in a directory called yourname within a directory called home, at the root of the Linux file system. There doesn't appear to be much in our current directory. Let's use a Bash flag to print all hidden files and directories to double check that's correct. Bash

Copy
ls -a
Whoa! That output showed us a lot more stuff in this directory than we initially thought. Output

Copy
yourname@Azure:~$ ls -a
. ..  .azure  .bash_history  .bash_logout  .bashrc  clouddrive  .profile  .tmux.conf  .viminfo
What were all of those files and subdirectories? Some are behind-the-scenes files to make Cloud Shell work. Let's discuss a few of the others. . refers to your current directory, and .. refers to your parent directory. Wherever you are, if you print all hidden files and directories, you'll see . and .. printed. .bash_history is a special Bash file where all commands that you enter into the shell are stored. Bash remembers your command history, which, as we'll see later, is useful. .bash_logout is another special Bash file that is read and run every time a login shell exists. Linux superusers can modify it to customize your environment. .bashrc is an important Bash configuration file that runs whenever you start a new shell. If you decide to open this file to look at it, be careful about making changes, because they can have unintended consequences.",What is the purpose of the clouddrive subdirectory in Cloud Shell?,The clouddrive subdirectory is a mounted file share that persists when using Cloud Shell on your own account. It acts as a persistent storage space for your files and data within Cloud Shell.
"Familiarize yourself with Cloud Shell
First, let's explore what's in Cloud Shell by using the Bash commands we've learned. Use the ls command to list all files and subdirectories in the current directory:

Bash

Copy
ls
You should see output that looks similar to this:

Output

Copy
yourname@Azure:~$ ls
clouddrive
clouddrive is a subdirectory of your current directory. It's a mounted file share that persists if you're using Cloud Shell on your own account. Right now, you're using it on the Microsoft Learn sandbox. But wait, what is the current directory? Let's use the pwd command to find out. pwd stands for ""print working directory."" It prints out the long-form path to what directory you're in now. Bash

Copy
pwd
You should see an output like this:

Output

Copy
yourname@Azure:~$ pwd
/home/yourname
This output means that you're in a directory called yourname within a directory called home, at the root of the Linux file system. There doesn't appear to be much in our current directory. Let's use a Bash flag to print all hidden files and directories to double check that's correct. Bash

Copy
ls -a
Whoa! That output showed us a lot more stuff in this directory than we initially thought. Output

Copy
yourname@Azure:~$ ls -a
. ..  .azure  .bash_history  .bash_logout  .bashrc  clouddrive  .profile  .tmux.conf  .viminfo
What were all of those files and subdirectories? Some are behind-the-scenes files to make Cloud Shell work. Let's discuss a few of the others. . refers to your current directory, and .. refers to your parent directory. Wherever you are, if you print all hidden files and directories, you'll see . and .. printed. .bash_history is a special Bash file where all commands that you enter into the shell are stored. Bash remembers your command history, which, as we'll see later, is useful. .bash_logout is another special Bash file that is read and run every time a login shell exists. Linux superusers can modify it to customize your environment. .bashrc is an important Bash configuration file that runs whenever you start a new shell. If you decide to open this file to look at it, be careful about making changes, because they can have unintended consequences.",What does the pwd command do in a Bash environment?,"The pwd command stands for ""print working directory."" It outputs the full path of the current directory you are working in, helping you understand your location within the file system."
"Familiarize yourself with Cloud Shell
First, let's explore what's in Cloud Shell by using the Bash commands we've learned. Use the ls command to list all files and subdirectories in the current directory:

Bash

Copy
ls
You should see output that looks similar to this:

Output

Copy
yourname@Azure:~$ ls
clouddrive
clouddrive is a subdirectory of your current directory. It's a mounted file share that persists if you're using Cloud Shell on your own account. Right now, you're using it on the Microsoft Learn sandbox. But wait, what is the current directory? Let's use the pwd command to find out. pwd stands for ""print working directory."" It prints out the long-form path to what directory you're in now. Bash

Copy
pwd
You should see an output like this:

Output

Copy
yourname@Azure:~$ pwd
/home/yourname
This output means that you're in a directory called yourname within a directory called home, at the root of the Linux file system. There doesn't appear to be much in our current directory. Let's use a Bash flag to print all hidden files and directories to double check that's correct. Bash

Copy
ls -a
Whoa! That output showed us a lot more stuff in this directory than we initially thought. Output

Copy
yourname@Azure:~$ ls -a
. ..  .azure  .bash_history  .bash_logout  .bashrc  clouddrive  .profile  .tmux.conf  .viminfo
What were all of those files and subdirectories? Some are behind-the-scenes files to make Cloud Shell work. Let's discuss a few of the others. . refers to your current directory, and .. refers to your parent directory. Wherever you are, if you print all hidden files and directories, you'll see . and .. printed. .bash_history is a special Bash file where all commands that you enter into the shell are stored. Bash remembers your command history, which, as we'll see later, is useful. .bash_logout is another special Bash file that is read and run every time a login shell exists. Linux superusers can modify it to customize your environment. .bashrc is an important Bash configuration file that runs whenever you start a new shell. If you decide to open this file to look at it, be careful about making changes, because they can have unintended consequences.",What is the function of the .bashrc file in a Linux environment?,"The .bashrc file is a Bash configuration file that executes whenever a new shell is started. It can be modified to customize the shell environment, but caution is advised as changes can lead to unintended consequences."
"Recall your history and autocomplete commands
When you're entering complicated commands like this one, it's easy to make a mistake:

Bash

Copy
ls -a .azure/commands/202? *.log
Fortunately, Bash offers a couple pieces of functionality to help you. Recalling previous commands
Try entering this command that has a typo (203? instead of 202? ):

Bash

Copy
ls -a .azure/commands/203? *.log
You should see this output letting you know that there weren't any files that matched that pattern:

Output

Copy
ls: cannot access '.azure/commands/203? *.log': No such file or directory
Rather than entering the whole thing again to correct your mistake, you can recall previously entered commands by using the Up arrow and Down arrow keys. Try using the Up arrow key to bring back your incorrect command. Then use the Left arrow key to fix it by replacing the final 3 with a 2. Select Enter again to submit the corrected command. Using the Up arrow key multiple times in a row will move you back multiple commands. Use the Down arrow key to move to later commands. Now you should see something like the following output. It lets you know that your command worked correctly to list files that matched the given pattern. Output

Copy
.azure/commands/2020-01-29.21-56-35.login.103.log
.azure/commands/2020-01-29.21-56-38.account_set.112.log
Autocompletion
Let's say you want to read the contents of one of the files that you just found. You can use the cat (short for ""catenate"") command to print the contents of a file to the screen. To use this command, you could use the full file name, such as:

Bash

Copy
cat .azure/commands/2020-01-29.21-56-35.login.103.log
But that's a lot to type, and very error prone. Instead, you can use Bash's rudimentary autocompletion to do most of the work for you. Try typing:

Bash

Copy
cat .a
Then select the Tab key. What happens? You should see the rest of the word ""azure/"" appear in your command:

Bash

Copy
cat .azure/
Keep typing the beginnings of words and using Tab to autocomplete. Keep in mind that if there's an ambiguity, Bash will not fill in anything.",How can you correct a command typo in Bash without retyping the entire command?,"You can correct a command typo in Bash by using the Up arrow key to recall the incorrect command, and then use the Left arrow key to navigate and fix the typo. After correcting the mistake, you can press Enter to execute the corrected command."
"Recall your history and autocomplete commands
When you're entering complicated commands like this one, it's easy to make a mistake:

Bash

Copy
ls -a .azure/commands/202? *.log
Fortunately, Bash offers a couple pieces of functionality to help you. Recalling previous commands
Try entering this command that has a typo (203? instead of 202? ):

Bash

Copy
ls -a .azure/commands/203? *.log
You should see this output letting you know that there weren't any files that matched that pattern:

Output

Copy
ls: cannot access '.azure/commands/203? *.log': No such file or directory
Rather than entering the whole thing again to correct your mistake, you can recall previously entered commands by using the Up arrow and Down arrow keys. Try using the Up arrow key to bring back your incorrect command. Then use the Left arrow key to fix it by replacing the final 3 with a 2. Select Enter again to submit the corrected command. Using the Up arrow key multiple times in a row will move you back multiple commands. Use the Down arrow key to move to later commands. Now you should see something like the following output. It lets you know that your command worked correctly to list files that matched the given pattern. Output

Copy
.azure/commands/2020-01-29.21-56-35.login.103.log
.azure/commands/2020-01-29.21-56-38.account_set.112.log
Autocompletion
Let's say you want to read the contents of one of the files that you just found. You can use the cat (short for ""catenate"") command to print the contents of a file to the screen. To use this command, you could use the full file name, such as:

Bash

Copy
cat .azure/commands/2020-01-29.21-56-35.login.103.log
But that's a lot to type, and very error prone. Instead, you can use Bash's rudimentary autocompletion to do most of the work for you. Try typing:

Bash

Copy
cat .a
Then select the Tab key. What happens? You should see the rest of the word ""azure/"" appear in your command:

Bash

Copy
cat .azure/
Keep typing the beginnings of words and using Tab to autocomplete. Keep in mind that if there's an ambiguity, Bash will not fill in anything.",What functionality does Bash provide to help reduce errors when typing long file paths or commands?,"Bash provides autocompletion functionality that allows you to type the beginning of a file path or command and then press the Tab key to automatically fill in the rest of the word, reducing errors and saving time."
"Recall your history and autocomplete commands
When you're entering complicated commands like this one, it's easy to make a mistake:

Bash

Copy
ls -a .azure/commands/202? *.log
Fortunately, Bash offers a couple pieces of functionality to help you. Recalling previous commands
Try entering this command that has a typo (203? instead of 202? ):

Bash

Copy
ls -a .azure/commands/203? *.log
You should see this output letting you know that there weren't any files that matched that pattern:

Output

Copy
ls: cannot access '.azure/commands/203? *.log': No such file or directory
Rather than entering the whole thing again to correct your mistake, you can recall previously entered commands by using the Up arrow and Down arrow keys. Try using the Up arrow key to bring back your incorrect command. Then use the Left arrow key to fix it by replacing the final 3 with a 2. Select Enter again to submit the corrected command. Using the Up arrow key multiple times in a row will move you back multiple commands. Use the Down arrow key to move to later commands. Now you should see something like the following output. It lets you know that your command worked correctly to list files that matched the given pattern. Output

Copy
.azure/commands/2020-01-29.21-56-35.login.103.log
.azure/commands/2020-01-29.21-56-38.account_set.112.log
Autocompletion
Let's say you want to read the contents of one of the files that you just found. You can use the cat (short for ""catenate"") command to print the contents of a file to the screen. To use this command, you could use the full file name, such as:

Bash

Copy
cat .azure/commands/2020-01-29.21-56-35.login.103.log
But that's a lot to type, and very error prone. Instead, you can use Bash's rudimentary autocompletion to do most of the work for you. Try typing:

Bash

Copy
cat .a
Then select the Tab key. What happens? You should see the rest of the word ""azure/"" appear in your command:

Bash

Copy
cat .azure/
Keep typing the beginnings of words and using Tab to autocomplete. Keep in mind that if there's an ambiguity, Bash will not fill in anything.",What happens if there is an ambiguity when using Bash's autocompletion feature?,"If there is an ambiguity when using Bash's autocompletion feature, Bash will not fill in anything, as it requires more specific input to determine the correct completion."
"You can select Tab twice to have Bash print out all the files and directories in a given path that match the letters you've typed already. Play around until you've gotten to a real .log file in the command directory. Then select Enter to use the cat command to print its contents to screen. It might look something like this:

Output

Copy
CMD-LOG-LINE-BEGIN 103 | 2020-01-29 21:56:35,426 | INFO | az_command_data_logger | command args: login --identity
CMD-LOG-LINE-BEGIN 103 | 2020-01-29 21:56:37,604 | INFO | az_command_data_logger | exit code: 0
Keep in mind that if you've typed an incorrect letter already, Bash will not be able to correctly guess what letter you meant to type. Use man
We just used the cat command, but you don't know much about it yet. Practice man to bring up more information about the cat command. Enter the following command to understand more about what cat is and how to use it:

Bash

Copy
man cat
Yes, you entered ""man cat"" into your shell. Bash commands can be both cryptic and amusing! You should see an output like this:

Output

Copy
CAT(1)                                       User Commands                                       CAT(1)

NAME
       cat - concatenate files and print on the standard output

SYNOPSIS
       cat [OPTION]... [FILE]... DESCRIPTION
       Concatenate FILE(s) to standard output. With no FILE, or when FILE is -, read standard input. -A, --show-all
              equivalent to -vET

       -b, --number-nonblank
              number nonempty output lines, overrides -n

       -e     equivalent to -vE

...
Use up and down arrows to scroll through the manual page, and enter q to exit. Change directories
Let's practice one more basic Bash command: cd. While using the shell, you're always sitting inside a directory—just like a folder on your PC or Mac. To change folders, you use the cd (change directory) command. It's simple, but let's get some practice. First, enter this command to make sure you're in the right place:

Bash

Copy
cd ~
This command moved you back to your special home directory in the shell, if you weren't already there.","What is the purpose of using the Tab key twice in Bash, and how does it assist in navigating directories?","Pressing the Tab key twice in Bash allows the shell to autocomplete file and directory names based on the letters you have started typing. This feature helps users navigate directories more efficiently by listing all available files and directories that match the typed characters, reducing the chance of typing errors."
"You can select Tab twice to have Bash print out all the files and directories in a given path that match the letters you've typed already. Play around until you've gotten to a real .log file in the command directory. Then select Enter to use the cat command to print its contents to screen. It might look something like this:

Output

Copy
CMD-LOG-LINE-BEGIN 103 | 2020-01-29 21:56:35,426 | INFO | az_command_data_logger | command args: login --identity
CMD-LOG-LINE-BEGIN 103 | 2020-01-29 21:56:37,604 | INFO | az_command_data_logger | exit code: 0
Keep in mind that if you've typed an incorrect letter already, Bash will not be able to correctly guess what letter you meant to type. Use man
We just used the cat command, but you don't know much about it yet. Practice man to bring up more information about the cat command. Enter the following command to understand more about what cat is and how to use it:

Bash

Copy
man cat
Yes, you entered ""man cat"" into your shell. Bash commands can be both cryptic and amusing! You should see an output like this:

Output

Copy
CAT(1)                                       User Commands                                       CAT(1)

NAME
       cat - concatenate files and print on the standard output

SYNOPSIS
       cat [OPTION]... [FILE]... DESCRIPTION
       Concatenate FILE(s) to standard output. With no FILE, or when FILE is -, read standard input. -A, --show-all
              equivalent to -vET

       -b, --number-nonblank
              number nonempty output lines, overrides -n

       -e     equivalent to -vE

...
Use up and down arrows to scroll through the manual page, and enter q to exit. Change directories
Let's practice one more basic Bash command: cd. While using the shell, you're always sitting inside a directory—just like a folder on your PC or Mac. To change folders, you use the cd (change directory) command. It's simple, but let's get some practice. First, enter this command to make sure you're in the right place:

Bash

Copy
cd ~
This command moved you back to your special home directory in the shell, if you weren't already there.","How can you use the 'man' command to learn more about other commands in Bash, and what specific information does it provide for the 'cat' command?","The 'man' command is used in Bash to access the manual pages for other commands, providing detailed information on their usage, options, and functionality. For the 'cat' command, the manual explains that it concatenates files and prints them on the standard output, and it describes various options like numbering nonblank lines and showing all characters."
"You can select Tab twice to have Bash print out all the files and directories in a given path that match the letters you've typed already. Play around until you've gotten to a real .log file in the command directory. Then select Enter to use the cat command to print its contents to screen. It might look something like this:

Output

Copy
CMD-LOG-LINE-BEGIN 103 | 2020-01-29 21:56:35,426 | INFO | az_command_data_logger | command args: login --identity
CMD-LOG-LINE-BEGIN 103 | 2020-01-29 21:56:37,604 | INFO | az_command_data_logger | exit code: 0
Keep in mind that if you've typed an incorrect letter already, Bash will not be able to correctly guess what letter you meant to type. Use man
We just used the cat command, but you don't know much about it yet. Practice man to bring up more information about the cat command. Enter the following command to understand more about what cat is and how to use it:

Bash

Copy
man cat
Yes, you entered ""man cat"" into your shell. Bash commands can be both cryptic and amusing! You should see an output like this:

Output

Copy
CAT(1)                                       User Commands                                       CAT(1)

NAME
       cat - concatenate files and print on the standard output

SYNOPSIS
       cat [OPTION]... [FILE]... DESCRIPTION
       Concatenate FILE(s) to standard output. With no FILE, or when FILE is -, read standard input. -A, --show-all
              equivalent to -vET

       -b, --number-nonblank
              number nonempty output lines, overrides -n

       -e     equivalent to -vE

...
Use up and down arrows to scroll through the manual page, and enter q to exit. Change directories
Let's practice one more basic Bash command: cd. While using the shell, you're always sitting inside a directory—just like a folder on your PC or Mac. To change folders, you use the cd (change directory) command. It's simple, but let's get some practice. First, enter this command to make sure you're in the right place:

Bash

Copy
cd ~
This command moved you back to your special home directory in the shell, if you weren't already there.","What does the 'cd ~' command do in Bash, and why might it be useful for users?","The 'cd ~' command in Bash changes the current directory to the user's home directory. It is useful because it allows users to quickly return to their home directory, which serves as a convenient starting point for navigating the file system or executing commands that depend on files or directories located there."
"Double check by using the pwd command one more time:

Bash

Copy
pwd
You should see an output like this:

Output

Copy
/home/yourname
~ is another special character in Bash that refers to this home directory. You can use ~ to refer to the location /home/yourname no matter where you are in the shell. Let's change to the directory that holds log files (where we were earlier):

Bash

Copy
cd .azure/commands/
You can either enter the full command yourself, or use Tab to autocomplete. Now you should see that the line where you enter commands looks different, showing you where you are in the shell:

Output

Copy
yourname@Azure:~/.azure/commands$
Try using the special .. syntax to move up one directory:

Bash

Copy
cd ..
Now you should be one level up in the directory structure, and your command line should look like this:

Output

Copy
yourname@Azure:~/.azure$
Great work! You've taken your first steps to being a Bash expert. Let's keep learning. Check your knowledge

1. What directory would you switch to if you entered cd . as a Bash command? My special ""home"" directory

The parent directory

The first alphabetical subdirectory

I wouldn't switch directories. 6- Exercise - Terminate a misbehaving process

Computers are imperfect. Sooner or later, something will go wrong. That's why you have a job as a sysadmin; it's up to you to troubleshoot and fix system problems. Imagine that a Python application is causing problems. Perhaps it's taking up too much CPU time, or maybe it has stopped responding. In either case, you want to stop the application. To identify a process or application, you can use ps and grep. Then, to stop it, you can use the kill command. Let's practice this in your Linux virtual machine. Start a misbehaving process
If you're going to kill a process, you need a process to kill. Let's create one. Get back to your home base by typing the following command:

Bash

Copy
cd ~
In Azure Cloud Shell, enter the following command to start Linux's vi editor:

Bash

Copy
vi bad.py
vi is a widely used text editor that Linux inherited from Unix. Love it or hate it, a Bash user needs to know the basics of vi. Select the i key to put vi in insert mode.",What does the pwd command do in Bash?,"The pwd command in Bash is used to print the current working directory, showing you the full path of the directory you are in."
"Double check by using the pwd command one more time:

Bash

Copy
pwd
You should see an output like this:

Output

Copy
/home/yourname
~ is another special character in Bash that refers to this home directory. You can use ~ to refer to the location /home/yourname no matter where you are in the shell. Let's change to the directory that holds log files (where we were earlier):

Bash

Copy
cd .azure/commands/
You can either enter the full command yourself, or use Tab to autocomplete. Now you should see that the line where you enter commands looks different, showing you where you are in the shell:

Output

Copy
yourname@Azure:~/.azure/commands$
Try using the special .. syntax to move up one directory:

Bash

Copy
cd ..
Now you should be one level up in the directory structure, and your command line should look like this:

Output

Copy
yourname@Azure:~/.azure$
Great work! You've taken your first steps to being a Bash expert. Let's keep learning. Check your knowledge

1. What directory would you switch to if you entered cd . as a Bash command? My special ""home"" directory

The parent directory

The first alphabetical subdirectory

I wouldn't switch directories. 6- Exercise - Terminate a misbehaving process

Computers are imperfect. Sooner or later, something will go wrong. That's why you have a job as a sysadmin; it's up to you to troubleshoot and fix system problems. Imagine that a Python application is causing problems. Perhaps it's taking up too much CPU time, or maybe it has stopped responding. In either case, you want to stop the application. To identify a process or application, you can use ps and grep. Then, to stop it, you can use the kill command. Let's practice this in your Linux virtual machine. Start a misbehaving process
If you're going to kill a process, you need a process to kill. Let's create one. Get back to your home base by typing the following command:

Bash

Copy
cd ~
In Azure Cloud Shell, enter the following command to start Linux's vi editor:

Bash

Copy
vi bad.py
vi is a widely used text editor that Linux inherited from Unix. Love it or hate it, a Bash user needs to know the basics of vi. Select the i key to put vi in insert mode.",How can you navigate to your home directory using a special character in Bash?,"You can navigate to your home directory in Bash by using the tilde (~) character, which is a shortcut that refers to your home directory, such as /home/yourname."
"Double check by using the pwd command one more time:

Bash

Copy
pwd
You should see an output like this:

Output

Copy
/home/yourname
~ is another special character in Bash that refers to this home directory. You can use ~ to refer to the location /home/yourname no matter where you are in the shell. Let's change to the directory that holds log files (where we were earlier):

Bash

Copy
cd .azure/commands/
You can either enter the full command yourself, or use Tab to autocomplete. Now you should see that the line where you enter commands looks different, showing you where you are in the shell:

Output

Copy
yourname@Azure:~/.azure/commands$
Try using the special .. syntax to move up one directory:

Bash

Copy
cd ..
Now you should be one level up in the directory structure, and your command line should look like this:

Output

Copy
yourname@Azure:~/.azure$
Great work! You've taken your first steps to being a Bash expert. Let's keep learning. Check your knowledge

1. What directory would you switch to if you entered cd . as a Bash command? My special ""home"" directory

The parent directory

The first alphabetical subdirectory

I wouldn't switch directories. 6- Exercise - Terminate a misbehaving process

Computers are imperfect. Sooner or later, something will go wrong. That's why you have a job as a sysadmin; it's up to you to troubleshoot and fix system problems. Imagine that a Python application is causing problems. Perhaps it's taking up too much CPU time, or maybe it has stopped responding. In either case, you want to stop the application. To identify a process or application, you can use ps and grep. Then, to stop it, you can use the kill command. Let's practice this in your Linux virtual machine. Start a misbehaving process
If you're going to kill a process, you need a process to kill. Let's create one. Get back to your home base by typing the following command:

Bash

Copy
cd ~
In Azure Cloud Shell, enter the following command to start Linux's vi editor:

Bash

Copy
vi bad.py
vi is a widely used text editor that Linux inherited from Unix. Love it or hate it, a Bash user needs to know the basics of vi. Select the i key to put vi in insert mode.",How can you stop a misbehaving process in a Linux environment?,"To stop a misbehaving process in a Linux environment, you can use the ps command to list processes and grep to filter them by name, then use the kill command followed by the process ID to terminate it."
"Then type in the following Python program:

Python

Copy
i = 0
while i == 0:
    pass
This program, when executed, runs in an infinite loop—clearly not something you want running on your server. Select the Esc key to exit insert mode. Then type the following command followed by the Enter key to save the program and exit vi:

vim

Copy
:wq
Be sure to include the colon at the beginning of the command. As for the remainder of the command, w stands for ""write"" and q stands for ""quit."" Now use the following command to start the program and leave it running in the background:

Bash

Copy
python3 bad.py &
Be sure to include the ampersand (&) at the end of the command. Otherwise, you won't return to the Bash prompt. In Bash, the ampersand runs a command and returns to the command line, even if the command hasn't finished running. It's not obvious, but bad.py is now running in the background and stealing CPU cycles from other processes. Let's take a close look at what's happening. Kill the process
To kill a process, you need the process name or process ID. This is a job for ps. To refresh your memory, a ps -ef command lists all running processes and displays a great deal of information about each. Use the following command to list all running processes and filter the results to lines that contain ""python"":

Bash

Copy
ps -ef | grep python
The results should look something like this:

Output

Copy
yourname+    342    254 99 23:34 pts/1    00:00:31 python3 bad.py
yourname+    344    254  0 23:35 pts/1    00:00:00 grep --color=auto python
From the listing, it appears that bad.py is consuming 99 percent of the server's CPU time. The program is living up to its name. The kill command kills a running process based on its process ID. (A related command named killall kills a process based on the process name.) When you call kill, you have to decide what kind of ""signal"" to use to kill the process.",What is the purpose of the colon at the beginning of the :wq command in vim?,"The colon at the beginning of the :wq command in vim is used to enter command mode, allowing you to execute commands like saving and exiting. In this case, :wq stands for ""write"" (save the file) and ""quit"" (exit vim)."
"Then type in the following Python program:

Python

Copy
i = 0
while i == 0:
    pass
This program, when executed, runs in an infinite loop—clearly not something you want running on your server. Select the Esc key to exit insert mode. Then type the following command followed by the Enter key to save the program and exit vi:

vim

Copy
:wq
Be sure to include the colon at the beginning of the command. As for the remainder of the command, w stands for ""write"" and q stands for ""quit."" Now use the following command to start the program and leave it running in the background:

Bash

Copy
python3 bad.py &
Be sure to include the ampersand (&) at the end of the command. Otherwise, you won't return to the Bash prompt. In Bash, the ampersand runs a command and returns to the command line, even if the command hasn't finished running. It's not obvious, but bad.py is now running in the background and stealing CPU cycles from other processes. Let's take a close look at what's happening. Kill the process
To kill a process, you need the process name or process ID. This is a job for ps. To refresh your memory, a ps -ef command lists all running processes and displays a great deal of information about each. Use the following command to list all running processes and filter the results to lines that contain ""python"":

Bash

Copy
ps -ef | grep python
The results should look something like this:

Output

Copy
yourname+    342    254 99 23:34 pts/1    00:00:31 python3 bad.py
yourname+    344    254  0 23:35 pts/1    00:00:00 grep --color=auto python
From the listing, it appears that bad.py is consuming 99 percent of the server's CPU time. The program is living up to its name. The kill command kills a running process based on its process ID. (A related command named killall kills a process based on the process name.) When you call kill, you have to decide what kind of ""signal"" to use to kill the process.",Why is it important to include the ampersand (&) when running a Python program in the background using Bash?,"Including the ampersand (&) at the end of a command in Bash is important because it allows the command to run in the background while returning control to the command line, enabling you to continue using the terminal for other tasks."
"Then type in the following Python program:

Python

Copy
i = 0
while i == 0:
    pass
This program, when executed, runs in an infinite loop—clearly not something you want running on your server. Select the Esc key to exit insert mode. Then type the following command followed by the Enter key to save the program and exit vi:

vim

Copy
:wq
Be sure to include the colon at the beginning of the command. As for the remainder of the command, w stands for ""write"" and q stands for ""quit."" Now use the following command to start the program and leave it running in the background:

Bash

Copy
python3 bad.py &
Be sure to include the ampersand (&) at the end of the command. Otherwise, you won't return to the Bash prompt. In Bash, the ampersand runs a command and returns to the command line, even if the command hasn't finished running. It's not obvious, but bad.py is now running in the background and stealing CPU cycles from other processes. Let's take a close look at what's happening. Kill the process
To kill a process, you need the process name or process ID. This is a job for ps. To refresh your memory, a ps -ef command lists all running processes and displays a great deal of information about each. Use the following command to list all running processes and filter the results to lines that contain ""python"":

Bash

Copy
ps -ef | grep python
The results should look something like this:

Output

Copy
yourname+    342    254 99 23:34 pts/1    00:00:31 python3 bad.py
yourname+    344    254  0 23:35 pts/1    00:00:00 grep --color=auto python
From the listing, it appears that bad.py is consuming 99 percent of the server's CPU time. The program is living up to its name. The kill command kills a running process based on its process ID. (A related command named killall kills a process based on the process name.) When you call kill, you have to decide what kind of ""signal"" to use to kill the process.",How can you find and terminate the Python program running in the background that is consuming too much CPU?,"You can find and terminate the Python program by using the ps -ef command to list all running processes and filter the results with grep to find the specific Python process. Once you have the process ID, you can use the kill command followed by the process ID to terminate it."
"Use the following command to display a list of signal types:

Bash

Copy
kill -l
If you were killing a daemon process—one that runs in the background and provides vital services to the operating system—you might want to kill it and immediately restart it. To do that, you could use a SIGHUP signal. In this example, you want to kill the process without restarting it. Therefore, you want to use the SIGKILL signal, which corresponds to the number 9. To that end, grab bad.py's process ID from the ps -ef output (it's in the second column) and use the following command to terminate the process. Replace PROCESS_ID with the process ID. Bash

Copy
kill -9 PROCESS_ID
The same command can also be entered as kill -s SIGKILL PROCESS_ID. Whether you use a signal's name or number is up to you. Finish by running ps again to confirm that bad.py is no longer running. Another common use for ps and kill is to identify and terminate ""zombie processes,"" which are child processes left behind by poorly written programs. Next unit: Exercise - Use Bash and grep to filter CLI output

7- Exercise - Use Bash and grep to filter CLI output

Until now, you've been running Bash commands on their own. Bash is extremely powerful when combined with other tools, so let's get some practice by using Bash to filter output from the Azure CLI. Let's say you want to see an up-to-date list of the VM sizes available in the westus region of Azure. You can do that with this command:

Bash

Copy
az vm list-sizes --location westus --output table
You should see a long list of VM types as an output. To narrow down this list to the VM sizes you're interested in, you can use grep, Linux's universal pattern-matching program. To find the ""DS"" sizes, popular for use in data science, use the following command:

Bash

Copy
az vm list-sizes --location westus --output table | grep DS
This pipes output from the az command to grep, which filters out lines that lack the ""DS"" string. That's still a lot of VMs. You know that DS V2 VMs are a more recent series. Let's adjust the grep command to use a more intricate regular expression:

Bash

Copy
az vm list-sizes --location westus --output table | grep DS.","What is the purpose of using the SIGKILL signal in process management, and how can it be executed in Bash?","The SIGKILL signal is used to immediately terminate a process without allowing it to perform any cleanup. It is executed in Bash using the `kill -9 PROCESS_ID` command, where `PROCESS_ID` is the process identification number obtained from the `ps -ef` output."
"Use the following command to display a list of signal types:

Bash

Copy
kill -l
If you were killing a daemon process—one that runs in the background and provides vital services to the operating system—you might want to kill it and immediately restart it. To do that, you could use a SIGHUP signal. In this example, you want to kill the process without restarting it. Therefore, you want to use the SIGKILL signal, which corresponds to the number 9. To that end, grab bad.py's process ID from the ps -ef output (it's in the second column) and use the following command to terminate the process. Replace PROCESS_ID with the process ID. Bash

Copy
kill -9 PROCESS_ID
The same command can also be entered as kill -s SIGKILL PROCESS_ID. Whether you use a signal's name or number is up to you. Finish by running ps again to confirm that bad.py is no longer running. Another common use for ps and kill is to identify and terminate ""zombie processes,"" which are child processes left behind by poorly written programs. Next unit: Exercise - Use Bash and grep to filter CLI output

7- Exercise - Use Bash and grep to filter CLI output

Until now, you've been running Bash commands on their own. Bash is extremely powerful when combined with other tools, so let's get some practice by using Bash to filter output from the Azure CLI. Let's say you want to see an up-to-date list of the VM sizes available in the westus region of Azure. You can do that with this command:

Bash

Copy
az vm list-sizes --location westus --output table
You should see a long list of VM types as an output. To narrow down this list to the VM sizes you're interested in, you can use grep, Linux's universal pattern-matching program. To find the ""DS"" sizes, popular for use in data science, use the following command:

Bash

Copy
az vm list-sizes --location westus --output table | grep DS
This pipes output from the az command to grep, which filters out lines that lack the ""DS"" string. That's still a lot of VMs. You know that DS V2 VMs are a more recent series. Let's adjust the grep command to use a more intricate regular expression:

Bash

Copy
az vm list-sizes --location westus --output table | grep DS.","How can you filter the output of a command in Bash to display only specific information, such as VM sizes in Azure?","You can filter command output in Bash by using the pipe operator (`|`) to send the output of one command as input to another. In the case of filtering Azure VM sizes, you can use `az vm list-sizes --location westus --output table | grep DS` to display only VM sizes that include the string ""DS""."
"Use the following command to display a list of signal types:

Bash

Copy
kill -l
If you were killing a daemon process—one that runs in the background and provides vital services to the operating system—you might want to kill it and immediately restart it. To do that, you could use a SIGHUP signal. In this example, you want to kill the process without restarting it. Therefore, you want to use the SIGKILL signal, which corresponds to the number 9. To that end, grab bad.py's process ID from the ps -ef output (it's in the second column) and use the following command to terminate the process. Replace PROCESS_ID with the process ID. Bash

Copy
kill -9 PROCESS_ID
The same command can also be entered as kill -s SIGKILL PROCESS_ID. Whether you use a signal's name or number is up to you. Finish by running ps again to confirm that bad.py is no longer running. Another common use for ps and kill is to identify and terminate ""zombie processes,"" which are child processes left behind by poorly written programs. Next unit: Exercise - Use Bash and grep to filter CLI output

7- Exercise - Use Bash and grep to filter CLI output

Until now, you've been running Bash commands on their own. Bash is extremely powerful when combined with other tools, so let's get some practice by using Bash to filter output from the Azure CLI. Let's say you want to see an up-to-date list of the VM sizes available in the westus region of Azure. You can do that with this command:

Bash

Copy
az vm list-sizes --location westus --output table
You should see a long list of VM types as an output. To narrow down this list to the VM sizes you're interested in, you can use grep, Linux's universal pattern-matching program. To find the ""DS"" sizes, popular for use in data science, use the following command:

Bash

Copy
az vm list-sizes --location westus --output table | grep DS
This pipes output from the az command to grep, which filters out lines that lack the ""DS"" string. That's still a lot of VMs. You know that DS V2 VMs are a more recent series. Let's adjust the grep command to use a more intricate regular expression:

Bash

Copy
az vm list-sizes --location westus --output table | grep DS.","What is the advantage of using grep with a more intricate regular expression when filtering command output, and how is it applied in the context of Azure VM sizes?","Using a more intricate regular expression with grep allows for more precise filtering of output by matching specific patterns. In the context of Azure VM sizes, adjusting the grep command to `grep DS` helps to filter the list down to VM sizes that match the desired pattern, such as the DS V2 series, providing more relevant results."
"*_v2
This filters out lines that don't match the regular expression DS.*_v2. You might recognize some of the characters in that expression from our discussion of ""wildcards"" in an earlier unit. Regular expressions make great use of wildcards. Regular expressions are a topic for another module, but come in handy for Bash scripting. Using Bash with other CLI commands makes the latter easier to work with. And because a sysadmin's work never ends, any tool that reduces the workload is welcome. Next unit: Knowledge check

Check your knowledge

1. Which of the following commands writes a list of processes associated with a user named scottgu to a file? cat | grep scottgu > processes.txt

cat > grep scottgu | processes.txt

ps -ef | grep scottgu > processes.txt

2. Which of the following commands, called with the -r option, would you use to delete a subdirectory that isn't empty? rm

rmdir

destroy

3. Which of the following commands combines the contents of foo.txt and bar.txt into a new file named foobar.txt? concat foo.txt bar.txt > foobar.txt

cat foo.txt bar.txt | foobar.txt

cat foo.txt bar.txt > foobar.txt

4. The purpose of the sudo command is to: 

Run a command with elevated privilege

Run a program and leave it running in the background

Prevent system files from being deleted by non-administrative users

5. Which of the following statements is true about the command python3 app.py &? It runs app.py after creating a restore point in the system

It runs app.py and returns immediately to the command prompt

It runs app.py, but only if it's located in the /etc directory

Summary

In this module, you learned the basics of using Bash. Among other things, you:

Learned what a shell is and what Bash is
Learned how Bash commands are structured
Learned key Bash commands, such as ls, cat, and ps
Learned how to use I/O operators in Bash commands to redirect input and output
Learned how to find and terminate rogue processes
Learned how to use Bash to filter output from another CLI tool
There is much more you can do with Bash. We've gotten comfortable using Bash as a way to interact with our shell, but you can use the commands you've learned (and many more) to use Bash for full-fledged programming.",What is the purpose of using regular expressions in Bash scripting?,"Regular expressions are used in Bash scripting to filter or match text patterns, making it easier to handle and manipulate text data efficiently. They allow for more precise and flexible text processing than simple wildcards."
"*_v2
This filters out lines that don't match the regular expression DS.*_v2. You might recognize some of the characters in that expression from our discussion of ""wildcards"" in an earlier unit. Regular expressions make great use of wildcards. Regular expressions are a topic for another module, but come in handy for Bash scripting. Using Bash with other CLI commands makes the latter easier to work with. And because a sysadmin's work never ends, any tool that reduces the workload is welcome. Next unit: Knowledge check

Check your knowledge

1. Which of the following commands writes a list of processes associated with a user named scottgu to a file? cat | grep scottgu > processes.txt

cat > grep scottgu | processes.txt

ps -ef | grep scottgu > processes.txt

2. Which of the following commands, called with the -r option, would you use to delete a subdirectory that isn't empty? rm

rmdir

destroy

3. Which of the following commands combines the contents of foo.txt and bar.txt into a new file named foobar.txt? concat foo.txt bar.txt > foobar.txt

cat foo.txt bar.txt | foobar.txt

cat foo.txt bar.txt > foobar.txt

4. The purpose of the sudo command is to: 

Run a command with elevated privilege

Run a program and leave it running in the background

Prevent system files from being deleted by non-administrative users

5. Which of the following statements is true about the command python3 app.py &? It runs app.py after creating a restore point in the system

It runs app.py and returns immediately to the command prompt

It runs app.py, but only if it's located in the /etc directory

Summary

In this module, you learned the basics of using Bash. Among other things, you:

Learned what a shell is and what Bash is
Learned how Bash commands are structured
Learned key Bash commands, such as ls, cat, and ps
Learned how to use I/O operators in Bash commands to redirect input and output
Learned how to find and terminate rogue processes
Learned how to use Bash to filter output from another CLI tool
There is much more you can do with Bash. We've gotten comfortable using Bash as a way to interact with our shell, but you can use the commands you've learned (and many more) to use Bash for full-fledged programming.",How does the 'sudo' command function in a Bash environment?,"The 'sudo' command is used to run a command with elevated privileges, typically administrative or root access, allowing users to perform tasks that require higher permission levels."
"*_v2
This filters out lines that don't match the regular expression DS.*_v2. You might recognize some of the characters in that expression from our discussion of ""wildcards"" in an earlier unit. Regular expressions make great use of wildcards. Regular expressions are a topic for another module, but come in handy for Bash scripting. Using Bash with other CLI commands makes the latter easier to work with. And because a sysadmin's work never ends, any tool that reduces the workload is welcome. Next unit: Knowledge check

Check your knowledge

1. Which of the following commands writes a list of processes associated with a user named scottgu to a file? cat | grep scottgu > processes.txt

cat > grep scottgu | processes.txt

ps -ef | grep scottgu > processes.txt

2. Which of the following commands, called with the -r option, would you use to delete a subdirectory that isn't empty? rm

rmdir

destroy

3. Which of the following commands combines the contents of foo.txt and bar.txt into a new file named foobar.txt? concat foo.txt bar.txt > foobar.txt

cat foo.txt bar.txt | foobar.txt

cat foo.txt bar.txt > foobar.txt

4. The purpose of the sudo command is to: 

Run a command with elevated privilege

Run a program and leave it running in the background

Prevent system files from being deleted by non-administrative users

5. Which of the following statements is true about the command python3 app.py &? It runs app.py after creating a restore point in the system

It runs app.py and returns immediately to the command prompt

It runs app.py, but only if it's located in the /etc directory

Summary

In this module, you learned the basics of using Bash. Among other things, you:

Learned what a shell is and what Bash is
Learned how Bash commands are structured
Learned key Bash commands, such as ls, cat, and ps
Learned how to use I/O operators in Bash commands to redirect input and output
Learned how to find and terminate rogue processes
Learned how to use Bash to filter output from another CLI tool
There is much more you can do with Bash. We've gotten comfortable using Bash as a way to interact with our shell, but you can use the commands you've learned (and many more) to use Bash for full-fledged programming.",What command would you use to combine the contents of 'foo.txt' and 'bar.txt' into a new file 'foobar.txt'?,You would use the command 'cat foo.txt bar.txt > foobar.txt' to combine the contents of 'foo.txt' and 'bar.txt' into a new file named 'foobar.txt'.
"Check out these resources for taking your Bash knowledge to the next level:



Point 4: Introduction to PowerShell

Learn about the basics of PowerShell, a cross-platform command-line shell and scripting language that's built for task automation and configuration management. Learn what PowerShell is, what it's used for, and how to use it. Learn about the basics of PowerShell, a cross-platform command-line shell and scripting language that's built for task automation and configuration management. Learn what PowerShell is, what it's used for, and how to use it. Learning objectives
After completing this module, you'll be able to:

Understand what PowerShell is and what you can use it for. Use commands to automate tasks. 1- Introduction

PowerShell is a command-line shell and a scripting language all in one. It was designed as a task engine that uses cmdlets to wrap tasks that people need to do. In PowerShell, you can run commands on local or remote machines. You can do tasks like managing users and automating workflows. Whether you're part of an operations team or a development team that's adopting DevOps principles, PowerShell can help. You can use it to address various tasks, such as managing cloud resources and continuous integration and continuous delivery (CI/CD). PowerShell offers many helpful commands, but you can expand its capabilities at any time by installing modules. When you install PowerShell, you can evaluate its features to see if it's a good fit for your team. Learning objectives
After completing this module, you'll be able to:

Understand what PowerShell is and what you can use it for. Use PowerShell commands to automate tasks. Prerequisites
Basic familiarity with using a command-line shell like Command Prompt or Git Bash. Visual Studio Code installed. Ability to install Visual Studio Code extensions. Ability to install software on your computer, if you're not using a Windows operating system. Next unit: What is PowerShell? 2- What is PowerShell? PowerShell consists of two parts: a command-line shell and a scripting language. It started out as a framework to automate administrative tasks in Windows. PowerShell has grown into a cross-platform tool that's used for many kinds of tasks. A command-line shell lacks a graphical interface, where you use a mouse to interact with graphical elements. Instead, you type text commands into a computer console. Here are some of the benefits of using a console:

Interacting with a console is often faster than using a graphical interface.","What is PowerShell, and what are its primary purposes?","PowerShell is a cross-platform command-line shell and scripting language designed for task automation and configuration management. It is used to run commands on local or remote machines, manage users, automate workflows, and address various tasks like managing cloud resources and continuous integration and continuous delivery (CI/CD)."
"Check out these resources for taking your Bash knowledge to the next level:



Point 4: Introduction to PowerShell

Learn about the basics of PowerShell, a cross-platform command-line shell and scripting language that's built for task automation and configuration management. Learn what PowerShell is, what it's used for, and how to use it. Learn about the basics of PowerShell, a cross-platform command-line shell and scripting language that's built for task automation and configuration management. Learn what PowerShell is, what it's used for, and how to use it. Learning objectives
After completing this module, you'll be able to:

Understand what PowerShell is and what you can use it for. Use commands to automate tasks. 1- Introduction

PowerShell is a command-line shell and a scripting language all in one. It was designed as a task engine that uses cmdlets to wrap tasks that people need to do. In PowerShell, you can run commands on local or remote machines. You can do tasks like managing users and automating workflows. Whether you're part of an operations team or a development team that's adopting DevOps principles, PowerShell can help. You can use it to address various tasks, such as managing cloud resources and continuous integration and continuous delivery (CI/CD). PowerShell offers many helpful commands, but you can expand its capabilities at any time by installing modules. When you install PowerShell, you can evaluate its features to see if it's a good fit for your team. Learning objectives
After completing this module, you'll be able to:

Understand what PowerShell is and what you can use it for. Use PowerShell commands to automate tasks. Prerequisites
Basic familiarity with using a command-line shell like Command Prompt or Git Bash. Visual Studio Code installed. Ability to install Visual Studio Code extensions. Ability to install software on your computer, if you're not using a Windows operating system. Next unit: What is PowerShell? 2- What is PowerShell? PowerShell consists of two parts: a command-line shell and a scripting language. It started out as a framework to automate administrative tasks in Windows. PowerShell has grown into a cross-platform tool that's used for many kinds of tasks. A command-line shell lacks a graphical interface, where you use a mouse to interact with graphical elements. Instead, you type text commands into a computer console. Here are some of the benefits of using a console:

Interacting with a console is often faster than using a graphical interface.",What are the prerequisites for learning and using PowerShell effectively?,"The prerequisites for learning PowerShell include having basic familiarity with using a command-line shell like Command Prompt or Git Bash, having Visual Studio Code installed, the ability to install Visual Studio Code extensions, and the ability to install software on your computer if you're not using a Windows operating system."
"Check out these resources for taking your Bash knowledge to the next level:



Point 4: Introduction to PowerShell

Learn about the basics of PowerShell, a cross-platform command-line shell and scripting language that's built for task automation and configuration management. Learn what PowerShell is, what it's used for, and how to use it. Learn about the basics of PowerShell, a cross-platform command-line shell and scripting language that's built for task automation and configuration management. Learn what PowerShell is, what it's used for, and how to use it. Learning objectives
After completing this module, you'll be able to:

Understand what PowerShell is and what you can use it for. Use commands to automate tasks. 1- Introduction

PowerShell is a command-line shell and a scripting language all in one. It was designed as a task engine that uses cmdlets to wrap tasks that people need to do. In PowerShell, you can run commands on local or remote machines. You can do tasks like managing users and automating workflows. Whether you're part of an operations team or a development team that's adopting DevOps principles, PowerShell can help. You can use it to address various tasks, such as managing cloud resources and continuous integration and continuous delivery (CI/CD). PowerShell offers many helpful commands, but you can expand its capabilities at any time by installing modules. When you install PowerShell, you can evaluate its features to see if it's a good fit for your team. Learning objectives
After completing this module, you'll be able to:

Understand what PowerShell is and what you can use it for. Use PowerShell commands to automate tasks. Prerequisites
Basic familiarity with using a command-line shell like Command Prompt or Git Bash. Visual Studio Code installed. Ability to install Visual Studio Code extensions. Ability to install software on your computer, if you're not using a Windows operating system. Next unit: What is PowerShell? 2- What is PowerShell? PowerShell consists of two parts: a command-line shell and a scripting language. It started out as a framework to automate administrative tasks in Windows. PowerShell has grown into a cross-platform tool that's used for many kinds of tasks. A command-line shell lacks a graphical interface, where you use a mouse to interact with graphical elements. Instead, you type text commands into a computer console. Here are some of the benefits of using a console:

Interacting with a console is often faster than using a graphical interface.","How does PowerShell enhance its capabilities, and what makes it suitable for various teams?","PowerShell enhances its capabilities by allowing the installation of modules, which expand its available commands and functionalities. It is suitable for various teams, including operations and development teams adopting DevOps principles, because it can automate workflows and manage resources efficiently across different platforms."
"In a console, you can run batches of commands, so it's ideal for task automation for continuous-integration pipelines. You can use a console to interact with cloud resources and other resources. You can store commands and scripts in a text file and use a source-control system. This capability is probably one of the biggest benefits, because your commands are repeatable and auditable. In many systems, especially government systems, everything must be traced and evaluated, or audited. Audits cover everything from database changes to changes done by a script. Features
PowerShell shares some features with traditional shells:

Built-in help system: Most shells have some kind of help system, in which you can learn more about a command. For example, you can learn what the command does and what parameters it supports. The help system in PowerShell provides information about commands and also integrates with online help articles. Pipeline: Traditional shells use a pipeline to run many commands sequentially. The output of one command is the input for the next command. PowerShell implements this concept like traditional shells, but it differs because it operates on objects over text. You learn more about this feature later in this module. Aliases: Aliases are alternate names that can be used to run commands. PowerShell supports the use of common aliases such as cls (clear the screen) and ls (list the files). Therefore, new users can use their knowledge of other frameworks and don't necessarily have to remember the PowerShell name for familiar commands. PowerShell differs from a traditional command-line shell in a few ways:

It operates on objects over text. In a command-line shell, you have to run scripts whose output and input might differ, so you end up spending time formatting the output and extracting the data you need. By contrast, in PowerShell you use objects as input and output. That means you spend less time formatting and extracting. It has cmdlets. Commands in PowerShell are called cmdlets (pronounced commandlets). In PowerShell, cmdlets are built on a common runtime rather than separate executables as they are in many other shell environments. This characteristic provides a consistent experience in parameter parsing and pipeline behavior. Cmdlets typically take object input and return objects. The core cmdlets in PowerShell are built in .NET Core, and are open source. You can extend PowerShell by using more cmdlets, scripts, and functions from the community and other sources, or you can build your own cmdlets in .NET Core or PowerShell. It has many types of commands.",How does using a console benefit continuous-integration pipelines?,"Using a console benefits continuous-integration pipelines by allowing for task automation through running batches of commands. This makes it easier to interact with cloud and other resources, and storing commands in a text file with source control makes them repeatable and auditable, which is essential for systems where everything must be traced and evaluated."
"In a console, you can run batches of commands, so it's ideal for task automation for continuous-integration pipelines. You can use a console to interact with cloud resources and other resources. You can store commands and scripts in a text file and use a source-control system. This capability is probably one of the biggest benefits, because your commands are repeatable and auditable. In many systems, especially government systems, everything must be traced and evaluated, or audited. Audits cover everything from database changes to changes done by a script. Features
PowerShell shares some features with traditional shells:

Built-in help system: Most shells have some kind of help system, in which you can learn more about a command. For example, you can learn what the command does and what parameters it supports. The help system in PowerShell provides information about commands and also integrates with online help articles. Pipeline: Traditional shells use a pipeline to run many commands sequentially. The output of one command is the input for the next command. PowerShell implements this concept like traditional shells, but it differs because it operates on objects over text. You learn more about this feature later in this module. Aliases: Aliases are alternate names that can be used to run commands. PowerShell supports the use of common aliases such as cls (clear the screen) and ls (list the files). Therefore, new users can use their knowledge of other frameworks and don't necessarily have to remember the PowerShell name for familiar commands. PowerShell differs from a traditional command-line shell in a few ways:

It operates on objects over text. In a command-line shell, you have to run scripts whose output and input might differ, so you end up spending time formatting the output and extracting the data you need. By contrast, in PowerShell you use objects as input and output. That means you spend less time formatting and extracting. It has cmdlets. Commands in PowerShell are called cmdlets (pronounced commandlets). In PowerShell, cmdlets are built on a common runtime rather than separate executables as they are in many other shell environments. This characteristic provides a consistent experience in parameter parsing and pipeline behavior. Cmdlets typically take object input and return objects. The core cmdlets in PowerShell are built in .NET Core, and are open source. You can extend PowerShell by using more cmdlets, scripts, and functions from the community and other sources, or you can build your own cmdlets in .NET Core or PowerShell. It has many types of commands.",What is a significant difference between PowerShell and traditional command-line shells?,"A significant difference between PowerShell and traditional command-line shells is that PowerShell operates on objects rather than text. This allows users to spend less time formatting and extracting data, as objects are used as input and output, providing a more streamlined experience compared to text-based operations in traditional shells."
"In a console, you can run batches of commands, so it's ideal for task automation for continuous-integration pipelines. You can use a console to interact with cloud resources and other resources. You can store commands and scripts in a text file and use a source-control system. This capability is probably one of the biggest benefits, because your commands are repeatable and auditable. In many systems, especially government systems, everything must be traced and evaluated, or audited. Audits cover everything from database changes to changes done by a script. Features
PowerShell shares some features with traditional shells:

Built-in help system: Most shells have some kind of help system, in which you can learn more about a command. For example, you can learn what the command does and what parameters it supports. The help system in PowerShell provides information about commands and also integrates with online help articles. Pipeline: Traditional shells use a pipeline to run many commands sequentially. The output of one command is the input for the next command. PowerShell implements this concept like traditional shells, but it differs because it operates on objects over text. You learn more about this feature later in this module. Aliases: Aliases are alternate names that can be used to run commands. PowerShell supports the use of common aliases such as cls (clear the screen) and ls (list the files). Therefore, new users can use their knowledge of other frameworks and don't necessarily have to remember the PowerShell name for familiar commands. PowerShell differs from a traditional command-line shell in a few ways:

It operates on objects over text. In a command-line shell, you have to run scripts whose output and input might differ, so you end up spending time formatting the output and extracting the data you need. By contrast, in PowerShell you use objects as input and output. That means you spend less time formatting and extracting. It has cmdlets. Commands in PowerShell are called cmdlets (pronounced commandlets). In PowerShell, cmdlets are built on a common runtime rather than separate executables as they are in many other shell environments. This characteristic provides a consistent experience in parameter parsing and pipeline behavior. Cmdlets typically take object input and return objects. The core cmdlets in PowerShell are built in .NET Core, and are open source. You can extend PowerShell by using more cmdlets, scripts, and functions from the community and other sources, or you can build your own cmdlets in .NET Core or PowerShell. It has many types of commands.","What are cmdlets in PowerShell, and how do they differ from commands in other shell environments?","Cmdlets in PowerShell are commands built on a common runtime rather than separate executables, which is typical in other shell environments. This provides a consistent experience in parameter parsing and pipeline behavior. Cmdlets generally take object input and return objects, and they are built in .NET Core, making them open source and extendable through additional cmdlets, scripts, and functions."
"Commands in PowerShell can be native executables, cmdlets, functions, scripts, or aliases. Every command you run belongs to one of these types. The words command and cmdlet are often used interchangeably, because a cmdlet is a type of command. Installation
In this module, you practice using PowerShell on your computer. PowerShell is available across platforms. However, if you use a computer that runs Linux, macOS, or an older version of Windows, you need to install it. Instructions for installing PowerShell are different for each OS. Before you continue, take a few minutes to install PowerShell or to verify your PowerShell installation. The next unit in this module shows you how to verify your installation. Windows
If you're running Windows 8 or later, a version of PowerShell called Windows PowerShell should already be installed. This version differs slightly from the most up-to-date PowerShell release, but it works fine for learning purposes. You can open Windows PowerShell from the Start menu. Other operating systems
If your computer runs something other than Windows 8 or later, you need to install PowerShell. To find the installation instructions for your OS, see Install various versions of PowerShell. PowerShell extension for Visual Studio Code
We recommend that you use the PowerShell extension for Visual Studio Code to author your PowerShell scripts and to run the commands in this module. This extension lets you run commands, and also helps you with snippets, code completion, and syntax highlighting. Next unit: Exercise - Run your first PowerShell commands

3- Exercise - Run your first PowerShell commands

In this unit, you use Azure Cloud Shell as a Linux terminal. You also can access Cloud Shell through the Azure portal or at Cloud Shell sign-in. You don't need to install anything on your PC or laptop to use Cloud Shell. Note

In this module, you're using the Azure Cloud Shell on the right-hand side of the screen, but in real-world situations, you can also use the integrated Terminal in Visual Studio Code by selecting Terminal > New Terminal, then selecting Powershell in the drop-down in the top-left of the Terminal window. Before beginning this exercise, be sure to activate the sandbox. Run the following command in Cloud Shell, and then press Enter to verify that your system is set up to use PowerShell. The $PSVersionTable verifies your installation.",What are the different types of commands you can run in PowerShell?,"In PowerShell, the different types of commands you can run include native executables, cmdlets, functions, scripts, and aliases."
"Commands in PowerShell can be native executables, cmdlets, functions, scripts, or aliases. Every command you run belongs to one of these types. The words command and cmdlet are often used interchangeably, because a cmdlet is a type of command. Installation
In this module, you practice using PowerShell on your computer. PowerShell is available across platforms. However, if you use a computer that runs Linux, macOS, or an older version of Windows, you need to install it. Instructions for installing PowerShell are different for each OS. Before you continue, take a few minutes to install PowerShell or to verify your PowerShell installation. The next unit in this module shows you how to verify your installation. Windows
If you're running Windows 8 or later, a version of PowerShell called Windows PowerShell should already be installed. This version differs slightly from the most up-to-date PowerShell release, but it works fine for learning purposes. You can open Windows PowerShell from the Start menu. Other operating systems
If your computer runs something other than Windows 8 or later, you need to install PowerShell. To find the installation instructions for your OS, see Install various versions of PowerShell. PowerShell extension for Visual Studio Code
We recommend that you use the PowerShell extension for Visual Studio Code to author your PowerShell scripts and to run the commands in this module. This extension lets you run commands, and also helps you with snippets, code completion, and syntax highlighting. Next unit: Exercise - Run your first PowerShell commands

3- Exercise - Run your first PowerShell commands

In this unit, you use Azure Cloud Shell as a Linux terminal. You also can access Cloud Shell through the Azure portal or at Cloud Shell sign-in. You don't need to install anything on your PC or laptop to use Cloud Shell. Note

In this module, you're using the Azure Cloud Shell on the right-hand side of the screen, but in real-world situations, you can also use the integrated Terminal in Visual Studio Code by selecting Terminal > New Terminal, then selecting Powershell in the drop-down in the top-left of the Terminal window. Before beginning this exercise, be sure to activate the sandbox. Run the following command in Cloud Shell, and then press Enter to verify that your system is set up to use PowerShell. The $PSVersionTable verifies your installation.",How can you verify your PowerShell installation on a system?,"You can verify your PowerShell installation by running the $PSVersionTable command, which provides information about the installed version of PowerShell on your system."
"Commands in PowerShell can be native executables, cmdlets, functions, scripts, or aliases. Every command you run belongs to one of these types. The words command and cmdlet are often used interchangeably, because a cmdlet is a type of command. Installation
In this module, you practice using PowerShell on your computer. PowerShell is available across platforms. However, if you use a computer that runs Linux, macOS, or an older version of Windows, you need to install it. Instructions for installing PowerShell are different for each OS. Before you continue, take a few minutes to install PowerShell or to verify your PowerShell installation. The next unit in this module shows you how to verify your installation. Windows
If you're running Windows 8 or later, a version of PowerShell called Windows PowerShell should already be installed. This version differs slightly from the most up-to-date PowerShell release, but it works fine for learning purposes. You can open Windows PowerShell from the Start menu. Other operating systems
If your computer runs something other than Windows 8 or later, you need to install PowerShell. To find the installation instructions for your OS, see Install various versions of PowerShell. PowerShell extension for Visual Studio Code
We recommend that you use the PowerShell extension for Visual Studio Code to author your PowerShell scripts and to run the commands in this module. This extension lets you run commands, and also helps you with snippets, code completion, and syntax highlighting. Next unit: Exercise - Run your first PowerShell commands

3- Exercise - Run your first PowerShell commands

In this unit, you use Azure Cloud Shell as a Linux terminal. You also can access Cloud Shell through the Azure portal or at Cloud Shell sign-in. You don't need to install anything on your PC or laptop to use Cloud Shell. Note

In this module, you're using the Azure Cloud Shell on the right-hand side of the screen, but in real-world situations, you can also use the integrated Terminal in Visual Studio Code by selecting Terminal > New Terminal, then selecting Powershell in the drop-down in the top-left of the Terminal window. Before beginning this exercise, be sure to activate the sandbox. Run the following command in Cloud Shell, and then press Enter to verify that your system is set up to use PowerShell. The $PSVersionTable verifies your installation.","What tool is recommended for authoring PowerShell scripts, and what features does it offer?","The PowerShell extension for Visual Studio Code is recommended for authoring PowerShell scripts. It offers features such as running commands, code snippets, code completion, and syntax highlighting."
"PowerShell

Copy
$PSVersionTable
Your output resembles the following table:

Output

Copy
 Name                           Value
 ----                           -----
 PSVersion                      7.3.6
 PSEdition                      Core
 GitCommitId                    7.3.6
 OS                             Linux 5.4.0-1058-azure #60~18.04.1-Ubuntu SMP Tue Aug 31 20:34:4…
 Platform                       Unix
 PSCompatibleVersions           {1.0, 2.0, 3.0, 4.0…}
 PSRemotingProtocolVersion      2.3
 SerializationVersion           1.1.0.1
 WSManStackVersion              3.0
The output provides information about your PowerShell version, and your platform and edition. For information limited to your version of PowerShell, you can run a modified version of $PSVersionTable. Run the following command in Cloud Shell, and then press Enter. PowerShell

Copy
$PSVersionTable.PSVersion
Your output now resembles the following table:

Output

Copy
Major  Minor  Patch  PreReleaseLabel BuildLabel
-----  -----  -----  --------------- ----------
7      3      6  
This output gives you more details about your version of PowerShell. Running $PSVersionTable results in output that looks like a table, but is actually an object. For this reason, you can use a period (.) to access a specific property, such as PSVersion. Next unit: Locate commands

4- Locate commands

A cmdlet (pronounced ""command-let"") is a compiled command. A cmdlet can be developed in .NET or .NET Core and invoked as a command within PowerShell. Thousands of cmdlets are available in your PowerShell installation. The challenge lies in discovering what the cmdlets are and what they can do for you. Cmdlets are named according to a verb-noun naming standard. This pattern can help you to understand what they do and how to search for them. It also helps cmdlet developers create consistent names. You can see the list of approved verbs by using the Get-Verb cmdlet. Verbs are organized according to activity type and function.",What is the significance of the $PSVersionTable in PowerShell?,"The $PSVersionTable in PowerShell provides detailed information about the PowerShell version, platform, and edition you are running. It displays a table, which is actually an object, containing properties like PSVersion, PSEdition, OS, and more, helping users understand their current PowerShell environment."
"PowerShell

Copy
$PSVersionTable
Your output resembles the following table:

Output

Copy
 Name                           Value
 ----                           -----
 PSVersion                      7.3.6
 PSEdition                      Core
 GitCommitId                    7.3.6
 OS                             Linux 5.4.0-1058-azure #60~18.04.1-Ubuntu SMP Tue Aug 31 20:34:4…
 Platform                       Unix
 PSCompatibleVersions           {1.0, 2.0, 3.0, 4.0…}
 PSRemotingProtocolVersion      2.3
 SerializationVersion           1.1.0.1
 WSManStackVersion              3.0
The output provides information about your PowerShell version, and your platform and edition. For information limited to your version of PowerShell, you can run a modified version of $PSVersionTable. Run the following command in Cloud Shell, and then press Enter. PowerShell

Copy
$PSVersionTable.PSVersion
Your output now resembles the following table:

Output

Copy
Major  Minor  Patch  PreReleaseLabel BuildLabel
-----  -----  -----  --------------- ----------
7      3      6  
This output gives you more details about your version of PowerShell. Running $PSVersionTable results in output that looks like a table, but is actually an object. For this reason, you can use a period (.) to access a specific property, such as PSVersion. Next unit: Locate commands

4- Locate commands

A cmdlet (pronounced ""command-let"") is a compiled command. A cmdlet can be developed in .NET or .NET Core and invoked as a command within PowerShell. Thousands of cmdlets are available in your PowerShell installation. The challenge lies in discovering what the cmdlets are and what they can do for you. Cmdlets are named according to a verb-noun naming standard. This pattern can help you to understand what they do and how to search for them. It also helps cmdlet developers create consistent names. You can see the list of approved verbs by using the Get-Verb cmdlet. Verbs are organized according to activity type and function.",How can you access specific properties of the $PSVersionTable object?,"You can access specific properties of the $PSVersionTable object by using a period (.) followed by the property name. For example, to access the PSVersion property, you would use $PSVersionTable.PSVersion, which provides more detailed information about the PowerShell version you are using."
"PowerShell

Copy
$PSVersionTable
Your output resembles the following table:

Output

Copy
 Name                           Value
 ----                           -----
 PSVersion                      7.3.6
 PSEdition                      Core
 GitCommitId                    7.3.6
 OS                             Linux 5.4.0-1058-azure #60~18.04.1-Ubuntu SMP Tue Aug 31 20:34:4…
 Platform                       Unix
 PSCompatibleVersions           {1.0, 2.0, 3.0, 4.0…}
 PSRemotingProtocolVersion      2.3
 SerializationVersion           1.1.0.1
 WSManStackVersion              3.0
The output provides information about your PowerShell version, and your platform and edition. For information limited to your version of PowerShell, you can run a modified version of $PSVersionTable. Run the following command in Cloud Shell, and then press Enter. PowerShell

Copy
$PSVersionTable.PSVersion
Your output now resembles the following table:

Output

Copy
Major  Minor  Patch  PreReleaseLabel BuildLabel
-----  -----  -----  --------------- ----------
7      3      6  
This output gives you more details about your version of PowerShell. Running $PSVersionTable results in output that looks like a table, but is actually an object. For this reason, you can use a period (.) to access a specific property, such as PSVersion. Next unit: Locate commands

4- Locate commands

A cmdlet (pronounced ""command-let"") is a compiled command. A cmdlet can be developed in .NET or .NET Core and invoked as a command within PowerShell. Thousands of cmdlets are available in your PowerShell installation. The challenge lies in discovering what the cmdlets are and what they can do for you. Cmdlets are named according to a verb-noun naming standard. This pattern can help you to understand what they do and how to search for them. It also helps cmdlet developers create consistent names. You can see the list of approved verbs by using the Get-Verb cmdlet. Verbs are organized according to activity type and function.","What naming convention is used for cmdlets in PowerShell, and why is it important?","Cmdlets in PowerShell use a verb-noun naming convention. This pattern is important because it helps users understand the function of a cmdlet and aids developers in creating consistent and intuitive cmdlet names. The Get-Verb cmdlet can be used to see the list of approved verbs, which are organized by activity type and function, further aiding in cmdlet discovery and usage."
"Here's a part of the output from running Get-Verb:

Output

Copy
Verb        AliasPrefix Group          Description
----        ----------- -----          -----------
Add         a           Common         Adds a resource to a container, or atta…
Clear       cl          Common         Removes all the resources from a contai…
This listing shows the verb and its description. Cmdlet developers should use an approved verb, and also ensure that the verb description fits their cmdlet's function. Three core cmdlets allow you to delve into what cmdlets exist and what they do:

Get-Command: The Get-Command cmdlet lists all of the available cmdlets on your system. Filter the list to quickly find the command you need. Get-Help: Run the Get-Help core cmdlet to invoke a built-in help system. You can also run an alias help command to invoke Get-Help but improve the reading experience by paginating the response. Get-Member: When you call a command, the response is an object that contains many properties. Run the Get-Member core cmdlet to drill down into that response and learn more about it. Locate commands by using Get-Command
When you run the Get-Command cmdlet in Cloud Shell, you get a list of every command that's installed in PowerShell. Because thousands of commands are installed, you need a way to filter the response so you can quickly locate the command that you need. To filter the list, keep in mind the verb-noun naming standard for cmdlets. For example, in the Get-Random command, Get is the verb and Random is the noun. Use flags to target either the verb or the noun in the command you want. The flag you specify expects a value that's a string. You can add pattern-matching characters to that string to ensure you express that, for example, a flag's value should start or end with a certain string. These examples show how to use flags to filter a command list:

-Noun: The -Noun flag targets the part of the command name that's related to the noun. Here's a typical search for a command name using alias as the noun for which we're searching:

PowerShell

Copy
Get-Command -Noun alias*
This command searches for all cmdlets whose noun part starts with alias. -Verb: The -Verb flag targets the part of the command name that's related to the verb. You can combine the -Noun flag and the -Verb flag to create an even more detailed search query and type.",What is the purpose of using the Get-Verb cmdlet in PowerShell?,"The Get-Verb cmdlet in PowerShell is used to display a list of approved verbs that should be used when naming cmdlets. It helps ensure that cmdlet developers use standard verb names that fit their cmdlet's function, providing consistency and clarity in command naming."
"Here's a part of the output from running Get-Verb:

Output

Copy
Verb        AliasPrefix Group          Description
----        ----------- -----          -----------
Add         a           Common         Adds a resource to a container, or atta…
Clear       cl          Common         Removes all the resources from a contai…
This listing shows the verb and its description. Cmdlet developers should use an approved verb, and also ensure that the verb description fits their cmdlet's function. Three core cmdlets allow you to delve into what cmdlets exist and what they do:

Get-Command: The Get-Command cmdlet lists all of the available cmdlets on your system. Filter the list to quickly find the command you need. Get-Help: Run the Get-Help core cmdlet to invoke a built-in help system. You can also run an alias help command to invoke Get-Help but improve the reading experience by paginating the response. Get-Member: When you call a command, the response is an object that contains many properties. Run the Get-Member core cmdlet to drill down into that response and learn more about it. Locate commands by using Get-Command
When you run the Get-Command cmdlet in Cloud Shell, you get a list of every command that's installed in PowerShell. Because thousands of commands are installed, you need a way to filter the response so you can quickly locate the command that you need. To filter the list, keep in mind the verb-noun naming standard for cmdlets. For example, in the Get-Random command, Get is the verb and Random is the noun. Use flags to target either the verb or the noun in the command you want. The flag you specify expects a value that's a string. You can add pattern-matching characters to that string to ensure you express that, for example, a flag's value should start or end with a certain string. These examples show how to use flags to filter a command list:

-Noun: The -Noun flag targets the part of the command name that's related to the noun. Here's a typical search for a command name using alias as the noun for which we're searching:

PowerShell

Copy
Get-Command -Noun alias*
This command searches for all cmdlets whose noun part starts with alias. -Verb: The -Verb flag targets the part of the command name that's related to the verb. You can combine the -Noun flag and the -Verb flag to create an even more detailed search query and type.",How can you filter the list of available cmdlets using the Get-Command cmdlet?,"You can filter the list of available cmdlets using the Get-Command cmdlet by utilizing the -Noun and -Verb flags. These flags allow you to target specific parts of the command name, enabling you to quickly locate the commands you need by specifying patterns related to the noun or verb of the command."
"Here's a part of the output from running Get-Verb:

Output

Copy
Verb        AliasPrefix Group          Description
----        ----------- -----          -----------
Add         a           Common         Adds a resource to a container, or atta…
Clear       cl          Common         Removes all the resources from a contai…
This listing shows the verb and its description. Cmdlet developers should use an approved verb, and also ensure that the verb description fits their cmdlet's function. Three core cmdlets allow you to delve into what cmdlets exist and what they do:

Get-Command: The Get-Command cmdlet lists all of the available cmdlets on your system. Filter the list to quickly find the command you need. Get-Help: Run the Get-Help core cmdlet to invoke a built-in help system. You can also run an alias help command to invoke Get-Help but improve the reading experience by paginating the response. Get-Member: When you call a command, the response is an object that contains many properties. Run the Get-Member core cmdlet to drill down into that response and learn more about it. Locate commands by using Get-Command
When you run the Get-Command cmdlet in Cloud Shell, you get a list of every command that's installed in PowerShell. Because thousands of commands are installed, you need a way to filter the response so you can quickly locate the command that you need. To filter the list, keep in mind the verb-noun naming standard for cmdlets. For example, in the Get-Random command, Get is the verb and Random is the noun. Use flags to target either the verb or the noun in the command you want. The flag you specify expects a value that's a string. You can add pattern-matching characters to that string to ensure you express that, for example, a flag's value should start or end with a certain string. These examples show how to use flags to filter a command list:

-Noun: The -Noun flag targets the part of the command name that's related to the noun. Here's a typical search for a command name using alias as the noun for which we're searching:

PowerShell

Copy
Get-Command -Noun alias*
This command searches for all cmdlets whose noun part starts with alias. -Verb: The -Verb flag targets the part of the command name that's related to the verb. You can combine the -Noun flag and the -Verb flag to create an even more detailed search query and type.",What function does the Get-Member cmdlet serve in PowerShell?,"The Get-Member cmdlet in PowerShell is used to explore the properties and methods of objects returned by other commands. It allows users to drill down into the response of a command to learn more about the object, its structure, and its capabilities."
"Here's an example:

PowerShell

Copy
Get-Command -Verb Get -Noun alias*
Now you've narrowed the search to specify that the verb part needs to match Get, and the noun part needs to match alias. Next unit: Exercise - Locate commands

5- Exercise - Locate commands

In this unit, you use the Azure Cloud Shell on the right-hand side as your Linux terminal. You can access Cloud Shell through the Azure portal or the Cloud Shell sign-in. You don't have to install anything on your PC or laptop to use it. Here, you run commands that help you learn more about PowerShell. PowerShell isn't something you learn overnight; it's learned command by command. You can speed up your learning by effectively using the core cmdlets. Locate a command
Locate commands by running the Get-Command cmdlet. This cmdlet helps you search all of the cmdlets installed on your system. Use flags to narrow down your search results to just the cmdlets that fit your scenario. In this scenario, you're looking for a cmdlet that can help you work with files. Run the command Get-Command with the flag -Noun. Specify File* to find anything related to files. PowerShell

Copy
 Get-Command -Noun File*
The response shows something similar to the following text:

Output

Copy
CommandType     Name                                               Version    Source
-----------     ----                                               -------    ------
Cmdlet          Get-FileHash                                       7.0.0.0    Microsoft.PowerShell.Utility
Cmdlet          Out-File                                           7.0.0.0    Microsoft.PowerShell.Utility
Cmdlet          Unblock-File                                       7.0.0.0    Microsoft.PowerShell.Utility
The cmdlets Get-FileHash, Out-File, and Unblock-File all match your query. Now, you have a manageable response. To further filter the response, add the -Verb parameter to your query. Run Get-Command. Specify the flags -Verb and -Noun. PowerShell

Copy
Get-Command -Verb Get -Noun File*
The result is similar to the following output:

Output

Copy
CommandType     Name                                               Version    Source
-----------     ----                                               -------    ------
Cmdlet          Get-FileHash                                       7.0.0.0    Microsoft.PowerShell.Utility
This time, only one record matches your search, because you specified both the -Noun parameter and the -Verb parameter.",What is the purpose of using the Get-Command cmdlet with specific flags in PowerShell?,"The purpose of using the Get-Command cmdlet with specific flags, such as -Noun and -Verb, is to narrow down the search results to find cmdlets that fit specific scenarios. This helps users locate relevant commands more efficiently by filtering commands based on their verb and noun parts."
"Here's an example:

PowerShell

Copy
Get-Command -Verb Get -Noun alias*
Now you've narrowed the search to specify that the verb part needs to match Get, and the noun part needs to match alias. Next unit: Exercise - Locate commands

5- Exercise - Locate commands

In this unit, you use the Azure Cloud Shell on the right-hand side as your Linux terminal. You can access Cloud Shell through the Azure portal or the Cloud Shell sign-in. You don't have to install anything on your PC or laptop to use it. Here, you run commands that help you learn more about PowerShell. PowerShell isn't something you learn overnight; it's learned command by command. You can speed up your learning by effectively using the core cmdlets. Locate a command
Locate commands by running the Get-Command cmdlet. This cmdlet helps you search all of the cmdlets installed on your system. Use flags to narrow down your search results to just the cmdlets that fit your scenario. In this scenario, you're looking for a cmdlet that can help you work with files. Run the command Get-Command with the flag -Noun. Specify File* to find anything related to files. PowerShell

Copy
 Get-Command -Noun File*
The response shows something similar to the following text:

Output

Copy
CommandType     Name                                               Version    Source
-----------     ----                                               -------    ------
Cmdlet          Get-FileHash                                       7.0.0.0    Microsoft.PowerShell.Utility
Cmdlet          Out-File                                           7.0.0.0    Microsoft.PowerShell.Utility
Cmdlet          Unblock-File                                       7.0.0.0    Microsoft.PowerShell.Utility
The cmdlets Get-FileHash, Out-File, and Unblock-File all match your query. Now, you have a manageable response. To further filter the response, add the -Verb parameter to your query. Run Get-Command. Specify the flags -Verb and -Noun. PowerShell

Copy
Get-Command -Verb Get -Noun File*
The result is similar to the following output:

Output

Copy
CommandType     Name                                               Version    Source
-----------     ----                                               -------    ------
Cmdlet          Get-FileHash                                       7.0.0.0    Microsoft.PowerShell.Utility
This time, only one record matches your search, because you specified both the -Noun parameter and the -Verb parameter.",How can Azure Cloud Shell be beneficial for learning and executing PowerShell commands?,"Azure Cloud Shell is beneficial for learning and executing PowerShell commands because it provides a Linux terminal accessible through the Azure portal or Cloud Shell sign-in, without requiring any installation on a PC or laptop. This convenience allows users to run and practice PowerShell commands easily in a cloud environment."
"Here's an example:

PowerShell

Copy
Get-Command -Verb Get -Noun alias*
Now you've narrowed the search to specify that the verb part needs to match Get, and the noun part needs to match alias. Next unit: Exercise - Locate commands

5- Exercise - Locate commands

In this unit, you use the Azure Cloud Shell on the right-hand side as your Linux terminal. You can access Cloud Shell through the Azure portal or the Cloud Shell sign-in. You don't have to install anything on your PC or laptop to use it. Here, you run commands that help you learn more about PowerShell. PowerShell isn't something you learn overnight; it's learned command by command. You can speed up your learning by effectively using the core cmdlets. Locate a command
Locate commands by running the Get-Command cmdlet. This cmdlet helps you search all of the cmdlets installed on your system. Use flags to narrow down your search results to just the cmdlets that fit your scenario. In this scenario, you're looking for a cmdlet that can help you work with files. Run the command Get-Command with the flag -Noun. Specify File* to find anything related to files. PowerShell

Copy
 Get-Command -Noun File*
The response shows something similar to the following text:

Output

Copy
CommandType     Name                                               Version    Source
-----------     ----                                               -------    ------
Cmdlet          Get-FileHash                                       7.0.0.0    Microsoft.PowerShell.Utility
Cmdlet          Out-File                                           7.0.0.0    Microsoft.PowerShell.Utility
Cmdlet          Unblock-File                                       7.0.0.0    Microsoft.PowerShell.Utility
The cmdlets Get-FileHash, Out-File, and Unblock-File all match your query. Now, you have a manageable response. To further filter the response, add the -Verb parameter to your query. Run Get-Command. Specify the flags -Verb and -Noun. PowerShell

Copy
Get-Command -Verb Get -Noun File*
The result is similar to the following output:

Output

Copy
CommandType     Name                                               Version    Source
-----------     ----                                               -------    ------
Cmdlet          Get-FileHash                                       7.0.0.0    Microsoft.PowerShell.Utility
This time, only one record matches your search, because you specified both the -Noun parameter and the -Verb parameter.",What are some cmdlets you might find when searching with the Get-Command -Noun File* command?,"When searching with the Get-Command -Noun File* command, you might find cmdlets such as Get-FileHash, Out-File, and Unblock-File. These cmdlets are related to file operations and match the search criteria specified by the -Noun parameter."
"Because the domain you work in is file management, you specified File as the noun. If you know what you want to do within that domain, you can specify -Verb parameters. By using one or possibly two parameters, you can quickly find the cmdlet you need. Next unit: Knowledge check

Choose the best response for each question, then select Check your answers. 1. What's a correct way to locate a command in PowerShell? Call Get-Command 'name of command'

Call Find 'name of command'

Call Locate 'name of command'

2. How would you search for commands that deal with files? Call Get-Command -Verb File*

Call Get-Command -Noun File

Call Get-Command -Noun File*

Summary

In this module, you started by learning what PowerShell is and what you can use it for. You explored its primary features and learned how to run your first commands. You then learned about compiled commands called cmdlets. You looked specifically at a command called Get-Command that helps you locate the command you need. You should now have a good understanding of PowerShell, what it's used for, and how to use its commands efficiently. Point 5: Configure resources with Azure Resource Manager templates

You'll learn how to use Azure Resource Manager templates to consistently deploy assets. Learning objectives
List the advantages of Azure templates. Identify the Azure template schema components. Specify Azure template parameters. Locate and use Azure Quickstart Templates. 1- Introduction

Scenario
Your company needs to ensure virtual machine deployments are consistent across the organization. You use Azure Resource Manager templates to deploy resources including virtual machines. Skills measured
Deploying resources using Azure Resource Manager templates is part of Exam AZ-104: Microsoft Azure Administrator. Deploy and manage Azure compute resources (20–25%)

Automate deployment of virtual machines (VMs) by using Azure Resource Manager templates

Modify an Azure Resource Manager template. Deploy from a template. Save a deployment as an Azure Resource Manager template. Learning objectives
In this module, you'll learn how to:

List the advantages of Azure templates. Identify the Azure template schema components. Specify Azure template parameters. Locate and use Azure Quickstart Templates. Prerequisites
None

Next unit: Review Azure Resource Manager template advantages

2- Review Azure Resource Manager template advantages

An Azure Resource Manager template precisely defines all the Resource Manager resources in a deployment. You can deploy a Resource Manager template into a resource group as a single operation. Using Resource Manager templates will make your deployments faster and more repeatable.",What is a cmdlet in the context of PowerShell and how does it help users?,A cmdlet is a compiled command in PowerShell that allows users to perform specific operations. It helps users by enabling them to locate and execute commands efficiently within the PowerShell environment.
"Because the domain you work in is file management, you specified File as the noun. If you know what you want to do within that domain, you can specify -Verb parameters. By using one or possibly two parameters, you can quickly find the cmdlet you need. Next unit: Knowledge check

Choose the best response for each question, then select Check your answers. 1. What's a correct way to locate a command in PowerShell? Call Get-Command 'name of command'

Call Find 'name of command'

Call Locate 'name of command'

2. How would you search for commands that deal with files? Call Get-Command -Verb File*

Call Get-Command -Noun File

Call Get-Command -Noun File*

Summary

In this module, you started by learning what PowerShell is and what you can use it for. You explored its primary features and learned how to run your first commands. You then learned about compiled commands called cmdlets. You looked specifically at a command called Get-Command that helps you locate the command you need. You should now have a good understanding of PowerShell, what it's used for, and how to use its commands efficiently. Point 5: Configure resources with Azure Resource Manager templates

You'll learn how to use Azure Resource Manager templates to consistently deploy assets. Learning objectives
List the advantages of Azure templates. Identify the Azure template schema components. Specify Azure template parameters. Locate and use Azure Quickstart Templates. 1- Introduction

Scenario
Your company needs to ensure virtual machine deployments are consistent across the organization. You use Azure Resource Manager templates to deploy resources including virtual machines. Skills measured
Deploying resources using Azure Resource Manager templates is part of Exam AZ-104: Microsoft Azure Administrator. Deploy and manage Azure compute resources (20–25%)

Automate deployment of virtual machines (VMs) by using Azure Resource Manager templates

Modify an Azure Resource Manager template. Deploy from a template. Save a deployment as an Azure Resource Manager template. Learning objectives
In this module, you'll learn how to:

List the advantages of Azure templates. Identify the Azure template schema components. Specify Azure template parameters. Locate and use Azure Quickstart Templates. Prerequisites
None

Next unit: Review Azure Resource Manager template advantages

2- Review Azure Resource Manager template advantages

An Azure Resource Manager template precisely defines all the Resource Manager resources in a deployment. You can deploy a Resource Manager template into a resource group as a single operation. Using Resource Manager templates will make your deployments faster and more repeatable.",How can Azure Resource Manager templates benefit an organization in terms of virtual machine deployment?,"Azure Resource Manager templates benefit an organization by ensuring consistent virtual machine deployments across the organization. They allow for faster and more repeatable deployments by defining all resources in a deployment precisely, which can be executed as a single operation."
"Because the domain you work in is file management, you specified File as the noun. If you know what you want to do within that domain, you can specify -Verb parameters. By using one or possibly two parameters, you can quickly find the cmdlet you need. Next unit: Knowledge check

Choose the best response for each question, then select Check your answers. 1. What's a correct way to locate a command in PowerShell? Call Get-Command 'name of command'

Call Find 'name of command'

Call Locate 'name of command'

2. How would you search for commands that deal with files? Call Get-Command -Verb File*

Call Get-Command -Noun File

Call Get-Command -Noun File*

Summary

In this module, you started by learning what PowerShell is and what you can use it for. You explored its primary features and learned how to run your first commands. You then learned about compiled commands called cmdlets. You looked specifically at a command called Get-Command that helps you locate the command you need. You should now have a good understanding of PowerShell, what it's used for, and how to use its commands efficiently. Point 5: Configure resources with Azure Resource Manager templates

You'll learn how to use Azure Resource Manager templates to consistently deploy assets. Learning objectives
List the advantages of Azure templates. Identify the Azure template schema components. Specify Azure template parameters. Locate and use Azure Quickstart Templates. 1- Introduction

Scenario
Your company needs to ensure virtual machine deployments are consistent across the organization. You use Azure Resource Manager templates to deploy resources including virtual machines. Skills measured
Deploying resources using Azure Resource Manager templates is part of Exam AZ-104: Microsoft Azure Administrator. Deploy and manage Azure compute resources (20–25%)

Automate deployment of virtual machines (VMs) by using Azure Resource Manager templates

Modify an Azure Resource Manager template. Deploy from a template. Save a deployment as an Azure Resource Manager template. Learning objectives
In this module, you'll learn how to:

List the advantages of Azure templates. Identify the Azure template schema components. Specify Azure template parameters. Locate and use Azure Quickstart Templates. Prerequisites
None

Next unit: Review Azure Resource Manager template advantages

2- Review Azure Resource Manager template advantages

An Azure Resource Manager template precisely defines all the Resource Manager resources in a deployment. You can deploy a Resource Manager template into a resource group as a single operation. Using Resource Manager templates will make your deployments faster and more repeatable.",What are some key components or features of Azure Resource Manager templates that users need to understand?,"Key components or features of Azure Resource Manager templates include the advantages of using them, the Azure template schema components, specifying Azure template parameters, and the ability to locate and use Azure Quickstart Templates. These aspects help users deploy and manage resources effectively."
"For example, you no longer have to create a VM in the portal, wait for it to finish, and then create the next VM. Resource Manager template takes care of the entire deployment for you. Template benefits
Templates improve consistency. Resource Manager templates provide a common language for you and others to describe your deployments. Regardless of the tool or SDK that you use to deploy the template, the structure, format, and expressions inside the template remain the same. Templates help express complex deployments. Templates enable you to deploy multiple resources in the correct order. For example, you wouldn't want to deploy a virtual machine prior to creating an operating system (OS) disk or network interface. Resource Manager maps out each resource and its dependent resources, and creates dependent resources first. Dependency mapping helps ensure that the deployment is carried out in the correct order. Templates reduce manual, error-prone tasks. Manually creating and connecting resources can be time consuming, and it's easy to make mistakes. Resource Manager ensures that the deployment happens the same way every time. Templates are code. Templates express your requirements through code. Think of a template as a type of Infrastructure as Code that can be shared, tested, and versioned similar to any other piece of software. Also, because templates are code, you can create a ""paper trail"" that you can follow. The template code documents the deployment. Most users maintain their templates under some kind of revision control, such as GIT. When you change the template, its revision history also documents how the template (and your deployment) has evolved over time. Templates promote reuse. Your template can contain parameters that are filled in when the template runs. A parameter can define a username or password, a domain name, and so on. Template parameters enable you to create multiple versions of your infrastructure, such as staging and production, while still using the exact same template. Templates are linkable. You can link Resource Manager templates together to make the templates themselves modular. You can write small templates that each define a piece of a solution, and then combine them to create a complete system. Templates simplify orchestration. You only need to deploy the template to deploy all of your resources. Normally this would take multiple operations. Next unit: Explore the Azure Resource Manager template schema

3- Explore the Azure Resource Manager template schema

Azure Resource Manager templates are written in JSON, which allows you to express data stored as an object (such as a virtual machine) in text. A JSON document is essentially a collection of key-value pairs.",How do Resource Manager templates improve the deployment process compared to manual methods?,"Resource Manager templates automate the entire deployment process by handling the creation of all necessary resources in the correct order, eliminating the need for manual, error-prone tasks. This ensures consistency and efficiency, as the deployment happens the same way every time, reducing the potential for mistakes."
"For example, you no longer have to create a VM in the portal, wait for it to finish, and then create the next VM. Resource Manager template takes care of the entire deployment for you. Template benefits
Templates improve consistency. Resource Manager templates provide a common language for you and others to describe your deployments. Regardless of the tool or SDK that you use to deploy the template, the structure, format, and expressions inside the template remain the same. Templates help express complex deployments. Templates enable you to deploy multiple resources in the correct order. For example, you wouldn't want to deploy a virtual machine prior to creating an operating system (OS) disk or network interface. Resource Manager maps out each resource and its dependent resources, and creates dependent resources first. Dependency mapping helps ensure that the deployment is carried out in the correct order. Templates reduce manual, error-prone tasks. Manually creating and connecting resources can be time consuming, and it's easy to make mistakes. Resource Manager ensures that the deployment happens the same way every time. Templates are code. Templates express your requirements through code. Think of a template as a type of Infrastructure as Code that can be shared, tested, and versioned similar to any other piece of software. Also, because templates are code, you can create a ""paper trail"" that you can follow. The template code documents the deployment. Most users maintain their templates under some kind of revision control, such as GIT. When you change the template, its revision history also documents how the template (and your deployment) has evolved over time. Templates promote reuse. Your template can contain parameters that are filled in when the template runs. A parameter can define a username or password, a domain name, and so on. Template parameters enable you to create multiple versions of your infrastructure, such as staging and production, while still using the exact same template. Templates are linkable. You can link Resource Manager templates together to make the templates themselves modular. You can write small templates that each define a piece of a solution, and then combine them to create a complete system. Templates simplify orchestration. You only need to deploy the template to deploy all of your resources. Normally this would take multiple operations. Next unit: Explore the Azure Resource Manager template schema

3- Explore the Azure Resource Manager template schema

Azure Resource Manager templates are written in JSON, which allows you to express data stored as an object (such as a virtual machine) in text. A JSON document is essentially a collection of key-value pairs.",What benefits do templates offer in terms of Infrastructure as Code?,"Templates act as a form of Infrastructure as Code, allowing requirements to be expressed through code. They can be shared, tested, and versioned like any software. This enables maintaining a history of changes through revision control systems like GIT, documenting the evolution of deployments over time."
"For example, you no longer have to create a VM in the portal, wait for it to finish, and then create the next VM. Resource Manager template takes care of the entire deployment for you. Template benefits
Templates improve consistency. Resource Manager templates provide a common language for you and others to describe your deployments. Regardless of the tool or SDK that you use to deploy the template, the structure, format, and expressions inside the template remain the same. Templates help express complex deployments. Templates enable you to deploy multiple resources in the correct order. For example, you wouldn't want to deploy a virtual machine prior to creating an operating system (OS) disk or network interface. Resource Manager maps out each resource and its dependent resources, and creates dependent resources first. Dependency mapping helps ensure that the deployment is carried out in the correct order. Templates reduce manual, error-prone tasks. Manually creating and connecting resources can be time consuming, and it's easy to make mistakes. Resource Manager ensures that the deployment happens the same way every time. Templates are code. Templates express your requirements through code. Think of a template as a type of Infrastructure as Code that can be shared, tested, and versioned similar to any other piece of software. Also, because templates are code, you can create a ""paper trail"" that you can follow. The template code documents the deployment. Most users maintain their templates under some kind of revision control, such as GIT. When you change the template, its revision history also documents how the template (and your deployment) has evolved over time. Templates promote reuse. Your template can contain parameters that are filled in when the template runs. A parameter can define a username or password, a domain name, and so on. Template parameters enable you to create multiple versions of your infrastructure, such as staging and production, while still using the exact same template. Templates are linkable. You can link Resource Manager templates together to make the templates themselves modular. You can write small templates that each define a piece of a solution, and then combine them to create a complete system. Templates simplify orchestration. You only need to deploy the template to deploy all of your resources. Normally this would take multiple operations. Next unit: Explore the Azure Resource Manager template schema

3- Explore the Azure Resource Manager template schema

Azure Resource Manager templates are written in JSON, which allows you to express data stored as an object (such as a virtual machine) in text. A JSON document is essentially a collection of key-value pairs.",How do parameters and modularity enhance the flexibility of Resource Manager templates?,"Parameters allow for dynamic input such as usernames or domain names, enabling the creation of different infrastructure versions from the same template. Modularity allows templates to be linked together, creating small, reusable templates that define parts of a solution, which can be combined to build a complete system, simplifying orchestration."
"Each key is a string, whose value can be:

A string
A number
A Boolean expression
A list of values
An object (which is a collection of other key-value pairs)
A Resource Manager template can contain sections that are expressed using JSON notation, but aren't related to the JSON language itself:

JSON

Copy
{
    ""$schema"": ""http://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#"",
    ""contentVersion"": """",
    ""parameters"": {},
    ""variables"": {},
    ""functions"": [],
    ""resources"": [],
    ""outputs"": {}
}

Element name

Required

Description

$schema

Yes

Location of the JSON schema file that describes the version of the template language. Use the URL shown in the preceding example. contentVersion

Yes

Version of the template (such as 1.0.0.0). You can provide any value for this element. Use this value to document significant changes in your template. This value can be used to make sure that the right template is being used. parameters

No

Values that are provided when deployment is executed to customize resource deployment. variables

No

Values that are used as JSON fragments in the template to simplify template language expressions. functions

No

User-defined functions that are available within the template. resources

Yes

Resource types that are deployed or updated in a resource group. outputs

No

Values that are returned after deployment. Next unit: Explore the Azure Resource Manager template parameters

4- Explore the Azure Resource Manager template parameters

In the parameters section of the template, you specify which values you can input when deploying the resources.",What is the purpose of the $schema element in a Resource Manager template?,The $schema element specifies the location of the JSON schema file that describes the version of the template language. It is required to ensure that the template conforms to the correct schema version.
"Each key is a string, whose value can be:

A string
A number
A Boolean expression
A list of values
An object (which is a collection of other key-value pairs)
A Resource Manager template can contain sections that are expressed using JSON notation, but aren't related to the JSON language itself:

JSON

Copy
{
    ""$schema"": ""http://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#"",
    ""contentVersion"": """",
    ""parameters"": {},
    ""variables"": {},
    ""functions"": [],
    ""resources"": [],
    ""outputs"": {}
}

Element name

Required

Description

$schema

Yes

Location of the JSON schema file that describes the version of the template language. Use the URL shown in the preceding example. contentVersion

Yes

Version of the template (such as 1.0.0.0). You can provide any value for this element. Use this value to document significant changes in your template. This value can be used to make sure that the right template is being used. parameters

No

Values that are provided when deployment is executed to customize resource deployment. variables

No

Values that are used as JSON fragments in the template to simplify template language expressions. functions

No

User-defined functions that are available within the template. resources

Yes

Resource types that are deployed or updated in a resource group. outputs

No

Values that are returned after deployment. Next unit: Explore the Azure Resource Manager template parameters

4- Explore the Azure Resource Manager template parameters

In the parameters section of the template, you specify which values you can input when deploying the resources.",How does the contentVersion element benefit the management of Resource Manager templates?,The contentVersion element is used to document significant changes in the template and ensures that the correct version of the template is being used. It allows for version control and tracking of template updates.
"Each key is a string, whose value can be:

A string
A number
A Boolean expression
A list of values
An object (which is a collection of other key-value pairs)
A Resource Manager template can contain sections that are expressed using JSON notation, but aren't related to the JSON language itself:

JSON

Copy
{
    ""$schema"": ""http://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#"",
    ""contentVersion"": """",
    ""parameters"": {},
    ""variables"": {},
    ""functions"": [],
    ""resources"": [],
    ""outputs"": {}
}

Element name

Required

Description

$schema

Yes

Location of the JSON schema file that describes the version of the template language. Use the URL shown in the preceding example. contentVersion

Yes

Version of the template (such as 1.0.0.0). You can provide any value for this element. Use this value to document significant changes in your template. This value can be used to make sure that the right template is being used. parameters

No

Values that are provided when deployment is executed to customize resource deployment. variables

No

Values that are used as JSON fragments in the template to simplify template language expressions. functions

No

User-defined functions that are available within the template. resources

Yes

Resource types that are deployed or updated in a resource group. outputs

No

Values that are returned after deployment. Next unit: Explore the Azure Resource Manager template parameters

4- Explore the Azure Resource Manager template parameters

In the parameters section of the template, you specify which values you can input when deploying the resources.",What role do parameters play in an Azure Resource Manager template?,Parameters in an Azure Resource Manager template allow for customization of resource deployment by specifying values that can be input during the deployment process. This flexibility helps tailor the deployment to specific needs or environments.
"The available properties for a parameter are:

JSON

Copy
""parameters"": {
    ""<parameter-name>"" : {
        ""type"" : ""<type-of-parameter-value>"",
        ""defaultValue"": ""<default-value-of-parameter>"",
        ""allowedValues"": [ ""<array-of-allowed-values>"" ],
        ""minValue"": <minimum-value-for-int>,
        ""maxValue"": <maximum-value-for-int>,
        ""minLength"": <minimum-length-for-string-or-array>,
        ""maxLength"": <maximum-length-for-string-or-array-parameters>,
        ""metadata"": {
        ""description"": ""<description-of-the parameter>""
        }
    }
}
Here's an example that illustrates two parameters: one for a virtual machine's username, and one for its password:

JSON

Copy
""parameters"": {
  ""adminUsername"": {
    ""type"": ""string"",
    ""metadata"": {
      ""description"": ""Username for the Virtual Machine."" }
  },
  ""adminPassword"": {
    ""type"": ""securestring"",
    ""metadata"": {
      ""description"": ""Password for the Virtual Machine."" }
  }
}
 Note

You're limited to 256 parameters in a template. You can reduce the number of parameters by using objects that contain multiple properties. Next unit: Consider Bicep templates

5- Consider Bicep templates

Azure Bicep is a domain-specific language (DSL) that uses declarative syntax to deploy Azure resources. It provides concise syntax, reliable type safety, and support for code reuse. You can use Bicep instead of JSON to develop your Azure Resource Manager templates (ARM templates). The JSON syntax to create an ARM template can be verbose and require complicated expressions. Bicep syntax reduces that complexity and improves the development experience. Bicep is a transparent abstraction over ARM template JSON and doesn't lose any of the JSON template capabilities. How does Bicep work? When you deploy a resource or series of resources to Azure, the tooling that's built into Bicep converts your Bicep template into a JSON template. This process is known as transpilation. Transpilation is the process of converting source code written in one language into another language. Bicep templates are converted to JSON templates..

Bicep provides many improvements over JSON for template authoring, including:

Simpler syntax: Bicep provides a simpler syntax for writing templates. You can reference parameters and variables directly, without using complicated functions.",What are the key differences between Bicep and JSON when authoring Azure Resource Manager templates?,"Bicep offers a simpler and more concise syntax compared to JSON, reducing complexity and improving the development experience. It features reliable type safety and supports code reuse. Unlike JSON, Bicep allows you to reference parameters and variables directly without using complicated functions, making it a transparent abstraction over ARM template JSON."
"The available properties for a parameter are:

JSON

Copy
""parameters"": {
    ""<parameter-name>"" : {
        ""type"" : ""<type-of-parameter-value>"",
        ""defaultValue"": ""<default-value-of-parameter>"",
        ""allowedValues"": [ ""<array-of-allowed-values>"" ],
        ""minValue"": <minimum-value-for-int>,
        ""maxValue"": <maximum-value-for-int>,
        ""minLength"": <minimum-length-for-string-or-array>,
        ""maxLength"": <maximum-length-for-string-or-array-parameters>,
        ""metadata"": {
        ""description"": ""<description-of-the parameter>""
        }
    }
}
Here's an example that illustrates two parameters: one for a virtual machine's username, and one for its password:

JSON

Copy
""parameters"": {
  ""adminUsername"": {
    ""type"": ""string"",
    ""metadata"": {
      ""description"": ""Username for the Virtual Machine."" }
  },
  ""adminPassword"": {
    ""type"": ""securestring"",
    ""metadata"": {
      ""description"": ""Password for the Virtual Machine."" }
  }
}
 Note

You're limited to 256 parameters in a template. You can reduce the number of parameters by using objects that contain multiple properties. Next unit: Consider Bicep templates

5- Consider Bicep templates

Azure Bicep is a domain-specific language (DSL) that uses declarative syntax to deploy Azure resources. It provides concise syntax, reliable type safety, and support for code reuse. You can use Bicep instead of JSON to develop your Azure Resource Manager templates (ARM templates). The JSON syntax to create an ARM template can be verbose and require complicated expressions. Bicep syntax reduces that complexity and improves the development experience. Bicep is a transparent abstraction over ARM template JSON and doesn't lose any of the JSON template capabilities. How does Bicep work? When you deploy a resource or series of resources to Azure, the tooling that's built into Bicep converts your Bicep template into a JSON template. This process is known as transpilation. Transpilation is the process of converting source code written in one language into another language. Bicep templates are converted to JSON templates..

Bicep provides many improvements over JSON for template authoring, including:

Simpler syntax: Bicep provides a simpler syntax for writing templates. You can reference parameters and variables directly, without using complicated functions.",How does the process of transpilation work in the context of Azure Bicep?,"In Azure Bicep, transpilation refers to the process of converting Bicep templates into JSON templates. When deploying resources to Azure, the built-in tooling within Bicep handles this conversion, ensuring that all the capabilities of JSON templates are retained while benefiting from the simplified syntax of Bicep."
"The available properties for a parameter are:

JSON

Copy
""parameters"": {
    ""<parameter-name>"" : {
        ""type"" : ""<type-of-parameter-value>"",
        ""defaultValue"": ""<default-value-of-parameter>"",
        ""allowedValues"": [ ""<array-of-allowed-values>"" ],
        ""minValue"": <minimum-value-for-int>,
        ""maxValue"": <maximum-value-for-int>,
        ""minLength"": <minimum-length-for-string-or-array>,
        ""maxLength"": <maximum-length-for-string-or-array-parameters>,
        ""metadata"": {
        ""description"": ""<description-of-the parameter>""
        }
    }
}
Here's an example that illustrates two parameters: one for a virtual machine's username, and one for its password:

JSON

Copy
""parameters"": {
  ""adminUsername"": {
    ""type"": ""string"",
    ""metadata"": {
      ""description"": ""Username for the Virtual Machine."" }
  },
  ""adminPassword"": {
    ""type"": ""securestring"",
    ""metadata"": {
      ""description"": ""Password for the Virtual Machine."" }
  }
}
 Note

You're limited to 256 parameters in a template. You can reduce the number of parameters by using objects that contain multiple properties. Next unit: Consider Bicep templates

5- Consider Bicep templates

Azure Bicep is a domain-specific language (DSL) that uses declarative syntax to deploy Azure resources. It provides concise syntax, reliable type safety, and support for code reuse. You can use Bicep instead of JSON to develop your Azure Resource Manager templates (ARM templates). The JSON syntax to create an ARM template can be verbose and require complicated expressions. Bicep syntax reduces that complexity and improves the development experience. Bicep is a transparent abstraction over ARM template JSON and doesn't lose any of the JSON template capabilities. How does Bicep work? When you deploy a resource or series of resources to Azure, the tooling that's built into Bicep converts your Bicep template into a JSON template. This process is known as transpilation. Transpilation is the process of converting source code written in one language into another language. Bicep templates are converted to JSON templates..

Bicep provides many improvements over JSON for template authoring, including:

Simpler syntax: Bicep provides a simpler syntax for writing templates. You can reference parameters and variables directly, without using complicated functions.","How can you reduce the number of parameters in a JSON template, and what is the maximum number allowed?","You can reduce the number of parameters in a JSON template by using objects that contain multiple properties, which allows you to consolidate related parameters. The maximum number of parameters allowed in a JSON template is 256."
"String interpolation is used in place of concatenation to combine values for names and other items. You can reference the properties of a resource directly by using its symbolic name instead of complex reference statements. These syntax improvements help both with authoring and reading Bicep templates. Modules: You can break down complex template deployments into smaller module files and reference them in a main template. These modules provide easier management and greater reusability. Automatic dependency management: In most situations, Bicep automatically detects dependencies between your resources. This process removes some of the work involved in template authoring. Type validation and IntelliSense: The Bicep extension for Visual Studio Code features rich validation and IntelliSense for all Azure resource type API definitions. This feature helps provide an easier authoring experience. Next unit: Review QuickStart templates

6- Review QuickStart templates

Azure Quickstart Templates are Azure Resource Manager templates provided by the Azure community. Screenshot of the QuickStart templates page. Some templates provide everything you need to deploy your solution, while others might serve as a starting point for your template. Either way, you can study these templates to learn how to best author and structure your own templates. The README.md file provides an overview of what the template does. The azuredeploy.json file defines the resources that will be deployed. The azuredeploy.parameters.json file provides the values the template needs. Note

Take a few minutes to browse the available templates. Anything of interest? Next unit: Interactive lab simulation - templates

7- Interactive lab simulation - templates

Scenario
Tailwind Traders are migrating their storage needs to Azure. You've successfully deployed a managed disk in a resource group. You've decided to create an Azure Resource Manager template to simplify the other disk deployments. Architecture diagram
Your first disk deployment in the resource group az104-03a-rg1 is complete. You plan to customize the template and use it to deploy another disk in resource group az104-03b-rg1. Architecture diagram as explained in the text. Tasks
Task 1: Review an ARM template for deployment of an Azure managed disk. Task 2: Create an Azure managed disk by using an ARM template. Task 3: Review the ARM template-based deployment of the managed disk. Note

Click on the thumbnail image to start the lab simulation. When you're done, be sure to return to this page so you can continue learning. Screenshot of the simulation page. Next unit: Knowledge check

Choose the best response for each question. Then select Check your answers. 1.",What are the benefits of using string interpolation over concatenation in Bicep templates?,"String interpolation in Bicep templates allows for easier reading and authoring by enabling direct referencing of resource properties using symbolic names, eliminating the need for complex reference statements that concatenation typically requires."
"String interpolation is used in place of concatenation to combine values for names and other items. You can reference the properties of a resource directly by using its symbolic name instead of complex reference statements. These syntax improvements help both with authoring and reading Bicep templates. Modules: You can break down complex template deployments into smaller module files and reference them in a main template. These modules provide easier management and greater reusability. Automatic dependency management: In most situations, Bicep automatically detects dependencies between your resources. This process removes some of the work involved in template authoring. Type validation and IntelliSense: The Bicep extension for Visual Studio Code features rich validation and IntelliSense for all Azure resource type API definitions. This feature helps provide an easier authoring experience. Next unit: Review QuickStart templates

6- Review QuickStart templates

Azure Quickstart Templates are Azure Resource Manager templates provided by the Azure community. Screenshot of the QuickStart templates page. Some templates provide everything you need to deploy your solution, while others might serve as a starting point for your template. Either way, you can study these templates to learn how to best author and structure your own templates. The README.md file provides an overview of what the template does. The azuredeploy.json file defines the resources that will be deployed. The azuredeploy.parameters.json file provides the values the template needs. Note

Take a few minutes to browse the available templates. Anything of interest? Next unit: Interactive lab simulation - templates

7- Interactive lab simulation - templates

Scenario
Tailwind Traders are migrating their storage needs to Azure. You've successfully deployed a managed disk in a resource group. You've decided to create an Azure Resource Manager template to simplify the other disk deployments. Architecture diagram
Your first disk deployment in the resource group az104-03a-rg1 is complete. You plan to customize the template and use it to deploy another disk in resource group az104-03b-rg1. Architecture diagram as explained in the text. Tasks
Task 1: Review an ARM template for deployment of an Azure managed disk. Task 2: Create an Azure managed disk by using an ARM template. Task 3: Review the ARM template-based deployment of the managed disk. Note

Click on the thumbnail image to start the lab simulation. When you're done, be sure to return to this page so you can continue learning. Screenshot of the simulation page. Next unit: Knowledge check

Choose the best response for each question. Then select Check your answers. 1.",How do modules in Bicep templates enhance template management and reuse?,"Modules in Bicep templates allow for complex template deployments to be broken down into smaller, manageable files that can be referenced in a main template, facilitating easier management and greater reusability of the templates."
"String interpolation is used in place of concatenation to combine values for names and other items. You can reference the properties of a resource directly by using its symbolic name instead of complex reference statements. These syntax improvements help both with authoring and reading Bicep templates. Modules: You can break down complex template deployments into smaller module files and reference them in a main template. These modules provide easier management and greater reusability. Automatic dependency management: In most situations, Bicep automatically detects dependencies between your resources. This process removes some of the work involved in template authoring. Type validation and IntelliSense: The Bicep extension for Visual Studio Code features rich validation and IntelliSense for all Azure resource type API definitions. This feature helps provide an easier authoring experience. Next unit: Review QuickStart templates

6- Review QuickStart templates

Azure Quickstart Templates are Azure Resource Manager templates provided by the Azure community. Screenshot of the QuickStart templates page. Some templates provide everything you need to deploy your solution, while others might serve as a starting point for your template. Either way, you can study these templates to learn how to best author and structure your own templates. The README.md file provides an overview of what the template does. The azuredeploy.json file defines the resources that will be deployed. The azuredeploy.parameters.json file provides the values the template needs. Note

Take a few minutes to browse the available templates. Anything of interest? Next unit: Interactive lab simulation - templates

7- Interactive lab simulation - templates

Scenario
Tailwind Traders are migrating their storage needs to Azure. You've successfully deployed a managed disk in a resource group. You've decided to create an Azure Resource Manager template to simplify the other disk deployments. Architecture diagram
Your first disk deployment in the resource group az104-03a-rg1 is complete. You plan to customize the template and use it to deploy another disk in resource group az104-03b-rg1. Architecture diagram as explained in the text. Tasks
Task 1: Review an ARM template for deployment of an Azure managed disk. Task 2: Create an Azure managed disk by using an ARM template. Task 3: Review the ARM template-based deployment of the managed disk. Note

Click on the thumbnail image to start the lab simulation. When you're done, be sure to return to this page so you can continue learning. Screenshot of the simulation page. Next unit: Knowledge check

Choose the best response for each question. Then select Check your answers. 1.",What role does the Azure Quickstart Templates page play in learning to author templates?,"The Azure Quickstart Templates page provides community-sourced ARM templates that can be used either as complete solutions or starting points for creating custom templates, offering a practical way to learn how to author and structure templates effectively."
"What is an Azure Resource Manager template? A series of Azure CLI commands to deploy infrastructure to Azure. A JavaScript Object Notation (JSON) file that defines the infrastructure and configuration for the deployment. A script used by the Azure Resource Manager to manage the Azure storage account. 2. Which of the following parameters is an element in the template schema? Includes

Scripts

Outputs

3. What happens if the same template is run a second time? Azure Resource Manager deploys the new resources as copies of the previously deployed resources. Azure Resource Manager doesn't change the deployed resources. Azure Resource Manager deletes the previously deployed resources and redeploys them. Summary and resources

To implement infrastructure as code for your Azure solutions, use Azure Resource Manager templates. The template is a JavaScript Object Notation (JSON) file that defines the infrastructure and configuration for your project. The template uses declarative syntax, which lets you state what you intend to deploy without having to write the sequence of programming commands to create it. In the template, you specify the resources to deploy and the properties for those resources. You should now be able to:

List the advantages of Azure templates. Identify the Azure template schema components. Specify Azure template parameters. Locate and use Azure Quickstart Templates. Learn more
You can learn more by reviewing the following. A sandbox indicates a hands-on exercise. Azure Resource Manager template documentation
Azure Quickstart Templates
Deploy Azure infrastructure by using JSON Azure Resource Manager templates (Sandbox)
Create Azure resources using Azure Resource Manager templates
Build your first Bicep template (Sandbox)

Module incomplete",What is the primary purpose of an Azure Resource Manager template?,"The primary purpose of an Azure Resource Manager template is to define the infrastructure and configuration for deployment in Azure using a JavaScript Object Notation (JSON) file, allowing for infrastructure as code with declarative syntax."
"What is an Azure Resource Manager template? A series of Azure CLI commands to deploy infrastructure to Azure. A JavaScript Object Notation (JSON) file that defines the infrastructure and configuration for the deployment. A script used by the Azure Resource Manager to manage the Azure storage account. 2. Which of the following parameters is an element in the template schema? Includes

Scripts

Outputs

3. What happens if the same template is run a second time? Azure Resource Manager deploys the new resources as copies of the previously deployed resources. Azure Resource Manager doesn't change the deployed resources. Azure Resource Manager deletes the previously deployed resources and redeploys them. Summary and resources

To implement infrastructure as code for your Azure solutions, use Azure Resource Manager templates. The template is a JavaScript Object Notation (JSON) file that defines the infrastructure and configuration for your project. The template uses declarative syntax, which lets you state what you intend to deploy without having to write the sequence of programming commands to create it. In the template, you specify the resources to deploy and the properties for those resources. You should now be able to:

List the advantages of Azure templates. Identify the Azure template schema components. Specify Azure template parameters. Locate and use Azure Quickstart Templates. Learn more
You can learn more by reviewing the following. A sandbox indicates a hands-on exercise. Azure Resource Manager template documentation
Azure Quickstart Templates
Deploy Azure infrastructure by using JSON Azure Resource Manager templates (Sandbox)
Create Azure resources using Azure Resource Manager templates
Build your first Bicep template (Sandbox)

Module incomplete",What are some of the components you can specify within an Azure Resource Manager template?,"Within an Azure Resource Manager template, you can specify resources to deploy, the properties for those resources, and parameters such as Scripts and Outputs, which are elements in the template schema."
"What is an Azure Resource Manager template? A series of Azure CLI commands to deploy infrastructure to Azure. A JavaScript Object Notation (JSON) file that defines the infrastructure and configuration for the deployment. A script used by the Azure Resource Manager to manage the Azure storage account. 2. Which of the following parameters is an element in the template schema? Includes

Scripts

Outputs

3. What happens if the same template is run a second time? Azure Resource Manager deploys the new resources as copies of the previously deployed resources. Azure Resource Manager doesn't change the deployed resources. Azure Resource Manager deletes the previously deployed resources and redeploys them. Summary and resources

To implement infrastructure as code for your Azure solutions, use Azure Resource Manager templates. The template is a JavaScript Object Notation (JSON) file that defines the infrastructure and configuration for your project. The template uses declarative syntax, which lets you state what you intend to deploy without having to write the sequence of programming commands to create it. In the template, you specify the resources to deploy and the properties for those resources. You should now be able to:

List the advantages of Azure templates. Identify the Azure template schema components. Specify Azure template parameters. Locate and use Azure Quickstart Templates. Learn more
You can learn more by reviewing the following. A sandbox indicates a hands-on exercise. Azure Resource Manager template documentation
Azure Quickstart Templates
Deploy Azure infrastructure by using JSON Azure Resource Manager templates (Sandbox)
Create Azure resources using Azure Resource Manager templates
Build your first Bicep template (Sandbox)

Module incomplete",What occurs if an Azure Resource Manager template is executed a second time?,"If an Azure Resource Manager template is executed a second time, Azure Resource Manager doesn't change the deployed resources, meaning it does not redeploy or delete the existing resources unless specifically configured to do so."
